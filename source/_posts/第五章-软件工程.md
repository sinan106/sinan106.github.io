---
title: 第五章 软件工程基础
date: 2020-10-18 11:23:27
tags:
- 软件工程
categories:
- 软考
---
# 5.1 软件工程概述

### 能力成熟度模型 CMM

> 对软件过后曾组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进，软件组织的能力经过这些阶段逐步提高。

CMM将软件过程改进分为以下5个成熟度级别

1. 初始级

2. 可重复级

3. 已定义级

4. 已管理级

5. 优化级

# 5.2 软件过程模型

  ### 1. 瀑布模型

> ​	将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落

##### 优点：

1. 容易理解，管理成本低
2. 强调开发的阶段性早期计划及需求调查和产品测试


##### 缺点：

1. 要求客户必须完整、正确和清晰的表达他们的需要
2. 在开始的两三个阶段中很难评估真正的进度状态，在快结束时会有大量的集成测试工作，直到整个项目完成之前都不能演示系统的能力
3. 需求或设计中的错误往往只有到了后期才能发现，**对于项目风险的控制能力较弱**。

### 2. 增量模型​	

> ​	假设将需求分段为一系列增量产品，每一增量可以分别开发。该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”

<img src="http://cdn.zhouxug.cn/20201018104619.png" alt="增量模型" style="zoom:125%;" />

##### 优点： 

1. 瀑布模型所有优点
2. 第一个可交付版本所需的成本和时间很少
3. 开发由增量表示的小系统所承担的风险较小

##### 缺点：

1. 若没有对用户的变更要求进行规划，那么产生的初始增量有可能导致之后的增量不稳定
2. 若需求不像早期思考的那样稳定和完整，一些增量就可能要重新开发，重新发布
3. 管理成本、进度和配置的复杂性较高

### 3. 原型模型

> ​	原型是预期系统的一个可执行版本，反应了系统性质的一个子集。一个原型不必满足所有约束，其目的是快速、低成本的构建原型。然后交付给客户使用，并收集反馈意见，这些意见将在下一轮中对原型进行改进。

##### 优点： 

​	适合在开发初期用户需求不清晰或经常变化的情况。当系统不太复杂时，采用该方法比较好

#### 增量模型与原型模型的区别

1. 增量的迭代可以并行，而原型不行
2. 增量是一般具有底层框架和平台的项目，而原型则是开发需求不明确、架构风险打的项目。

### 4. 螺旋模型

> ​	对于复杂的大型软件，开发一个原型通常达不到要求。螺旋模型将瀑布模型和演化结合起来，加入了风险分析。

螺旋模型将开发过程分为几个螺旋周期，每个周期大致和瀑布模型相符。四步流程如下
 1. 制定计划
 2. 风险分析
 3. 实施工程
 4. 用户评估

![螺旋模型](http://cdn.zhouxug.cn/20201018104623.png)

**螺旋模型强调风险分析，<u>因此特别适合庞大、复杂且具有高风险的系统</u>**    ctrl + u 下划线

##### 优点： 

1. 支持用户需求的动态变化，有助于提高软件的适应能力
2. 为项目管理人员及时调整管理决策提供了便利，从而降低了风险

##### 缺点：

1. 要求开发人员有相当丰富的风险评估能力和专业知识
2. 过多的迭代次数会增加开发成本，延迟提交时间

### 5. 喷泉模型

> 以用户需求为动力，以对象作为驱动的模型，**适合面向对象的开发**

![image-20201014193317591](http://cdn.zhouxug.cn/20201018104628.png)

##### 优点： 

1. 克服了瀑布模型和多项开发活动集成的局限性
2. 允许各个开发活动交叉迭代进行，不必每次 需求分析 -> 设计活动 -> 编码，提高开发效率节省了大量开发时间

##### 缺点：

1. 由于开发的各个阶段是重叠的，需要大量的开发人员，不利于项目管理
2. 要求严格的文档管理，审核难度大

### 6. 统一过程模型 UP

> "用例和风险驱动，以架构为中心，迭代并且增量"的开发模型

统一过程定义了4个技术阶段及其制品

1. 起始阶段：生命周期目标
2. 精化阶段：生命周期架构
3. 构建阶段：初始运作功能
4. 移交阶段：产品发布

### 7. 敏捷方法

> 软件开发过程中加入灵活性，能在开发周期的后期增加或改变需求

#### 1. 极限编程 XP

> 主要解决代码质量低的问题，无法提升代码速度

四大价值观：

1. 沟通
2. 简单性
3. 反馈
4. 勇气

#### 2. 水晶法 Crystal

> 每一个不同的项目都需要一套不同的策略、约定和方法论，认为人对软件质量有重要的影响。通过更好地交流和经常性的交付，软件生产力得到提高

#### 3. 并列争求法 Scrum

> 使用迭代的方法，把每30天一次的迭代称为一个“冲刺”。多个自组织和自治的小组**并行**地递增且**竞争**实现产品。

#### 4. 自适应软件开发 ASD

# 5.3 测试方法

### 1. 黑盒测试

> 也称为功能测试，在完全不考虑软件内部结构和特性情况下，测试软件外部特性

### 2.白盒测试

> 也成为结构测试，根据程序内部机构和逻辑来设计测试用例，对程序的路径和过程进行测试

##### 1. 语句覆盖

只用满足一个案例，走过所有的语句即可

##### 2. 判定(分支)覆盖

对于判断语句，要设定T/F，相比语句覆盖，新增False

<img src="http://cdn.zhouxug.cn/20201018104631.png" alt="image-20201017153157639" style="zoom:80%;" />

##### 3. 条件覆盖

判断语句中变量每个值都要考虑一遍

<img src="http://cdn.zhouxug.cn/20201018104634.png" alt="image-20201017153212357" style="zoom:80%;" />

##### 4. 判定/条件覆盖

判定覆盖各条件覆盖交叉，针对于判定中的条件取值 

<img src="http://cdn.zhouxug.cn/20201018104636.png" alt="image-20201017153319004" style="zoom:80%;" />

##### 5. 组合覆盖

<img src="http://cdn.zhouxug.cn/20201018104638.png" alt="image-20201017153349607" style="zoom:80%;" />

##### 6. 路径覆盖

<img src="http://cdn.zhouxug.cn/20201018104642.png" alt="image-20201017153412730" style="zoom:80%;" />

# 5.4 进度管理

### 1. Gantt图

> 清晰地描述每个任务从何时开始，到何时结束，任务进度进展情况以及各个任务之间的并行性。但是不能反映各任务间的依赖关系，难以确定项目的关键

![image-20201017153850807](http://cdn.zhouxug.cn/20201018104644.png)

### 2. PERT图 （类似AOE网）

> PERT图给出了每个任务的开始时间、结束时间该任务完成所需时间，还给出了任务间的关系，即哪些任务完成后才能开始另一项任务。**松弛时间反映了完成某些任务时可以推迟其开始时间或延长完成时间**，但是PERT图不能反映任务间的并行关系。

# 5.5 软件评审

### 1. 软件质量的评审内容

1. 功能结构：在软件设计中占有极其重要的地位，软件评审时必须明确软件的数据结构，需检查的项目如下
	1. 数据结构
	2. 功能结构
	3. 数据结构和功能结构之间的对应关系
2. 功能的通用性
3. 模块的层次
4. 模块结构

# 5.6 软件度量

### 1. McCabe 度量法

> 又称为环路度量，他认为循环和选择构成的环路越多，程序就越复杂。他把程序流程图中的每个处理符号都退化成为一个结点，原来连接不同处理符号的流线变成连接不同点的有向弧，这样得到的有向图称为**程序图**。

**McCabe环路复杂度: V(G) = m - n = 2 * p**

**m 是图G中弧的个数，n是图G的结点数，p是G中的强连通分量个数，通常取1**

ps: 

1. 顶点强连通：有向图中u,v两点，u -> v, v -> u 都有一条有向的路径，则称这两点连通
2. 强连通图：若所有节点都是强连通，则该图为强连通图
3. 强连通分量：有向非连通图的极大强连通子图

当环路复杂度超过10时，要充分测试这个模块就变得十分困难，

---
title: 3.存储系统
date: 2021-04-20 20:04:09
tags:
- 计算机组成原理
categories:
- 408笔记
---

# 3.1 存储器概述

### 3.1.1 存储器分类

#### 1. 作用 / 层次分类

1. 主存储器：CPU可直接访问，也可以和Cache以及辅存交换数据
2. 辅存储器：不能与CPU直接交换数据
3. 高速缓冲存储器：用于存放正在执行的数据，用于提升存储效率

**注：CPU 与Cache交换数据以字为单位，Cache与主存数据交换以Cache块为单位**

#### 2. 存储介质

1. 磁表面：磁盘、磁带、磁心存储器、半导体存储器（MOS，双极型）
2. 光存储：光盘

#### *3. 存取方式

1. 随机存储器 / RAM：存储器任何一个存储单元的内容都可以随机存取，且存取时间与存储单元物理位置无关

2. 只读存储器 / ROM：广义上的只读存储器已通过电擦除等方式可进行写入，**其“只读”概念没有保留，仅保留断电内容保留、随机读取特性，但写入速度比读取速度慢得多**。

	1. 掩模式只读存储器 / MROM：在生产过程中直接写入，以后任何人都无法改变其内容

	2. 一次可编程只读存储器 / PROM：允许用户用专门设备写入程序，写入后内容就无法改变

	3. 可擦除可编程只读存储器 / EPROM：可多次改写，修改时先全部擦除，再编程。编程次数有限，写入时间过长

		1. 紫外线擦除(UVEPROM)
		2. 电擦除(EEPROM)

	4. 闪速存储器(Flash Memory):EPROM和EEPROM(电可擦除可编程存储器)基础上发展而来，**用MOS管上的浮栅有无电荷来存储信息；写入时仍要先擦去原有数据，因此写入速度比读速度满不少。**

		*u盘*

	5. 固态硬盘：由控制单元和**闪存存储器**构成。

	**注1： HDD不是ROM，是硬盘，硬盘是磁盘的一种，即直接存取存储器**

	**注2：ROM和RAM均是随机存取方式，随机存取方式不一定是随机存取存储器**

3. 串行访问存储器：读写操作时，按其物理位置下的先后进行寻址

	1. 顺序存取存储器：只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，其特点是存取速度慢。

		*磁带*

	2. 直接存取存储器 / 半顺序存取存储器：寻找整个存储器中的某个小区域（如磁盘上的磁道），再在小区域内顺序查找。

		*磁盘，光盘*

#### 4. 信息可保存性：

1. 断电后存储信息是否消失:易失性(RAM)、非易失性
2. 读出是否破坏信息:破坏性读出(DRAM)、非破坏性读出

#### 5. 补充：相联存储器

​	把存储单元所存取的内容的某一部分作为检索项 / 关键字去检索该存储器，并将存储器中与该检索项符合的存储单元进行读出和写入，**按内容或地址寻址**

​	*TLB快表、相联Cache*

### 3.1.2 性能指标

1. 存储容量:存储字数 * 字长(如1M * 8位)

2. 单位成本:每位价格 = 总成本 / 总容量

3. 存储速度:数据传输率 = 数据的宽度 / 存储周期

	1. 存取时间(Ta)：一次读操作从开始到完成，将数据读出到数据总线上的时间。由于写操作时间 ≈ 读操作时间，故称为存取时间

	2. 存取周期(Tm):存取周期又称为读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间,即连续两次独立地访问存储器操作(读或写操作)之间所需的最小时间间隔。

		<img src="http://cdn.zhouxug.cn/20210420212035.png" alt="image-20210420212035375" style="zoom:67%;" />

	3. 主存带宽(Bm):主存带宽又称数据传输率或存储器带宽，表示每秒从主存进出信息的最大数量,单位为字/秒,字节/秒(B/s)或位/秒(b/s)。

# 3.2 存储层次化结构
### 1. 多级存储器结构

<img src="http://cdn.zhouxug.cn/20210420212648.png" alt="image-20210420212648758" style="zoom:67%;" />

### 2. 三级存储器结构

1. Cache-主存层次；硬件实现,解决速度不匹配问题。**主存和Cache间的数据调动全部是由硬件完成，对所有程序员都是透明的**

2. 主存-辅存层次；硬件+操作系统实现,解决容量问题,逐渐形成虚拟存储系统。**主存和辅存间的数据调动由硬件和操作系统共同完成，对应用程序员透明，系统程序员不透明，页式和段页式则对应用程序员半透明。**

	<img src="http://cdn.zhouxug.cn/20210420213308.png" style="zoom:67%;" />

# 3.3 半导体随机存储器

> ​	把存放一份二进制位的物理器件称为存储元，地址码相同的存储元组成一个存储单元，多个存储单元组成存储体

### 3.3.1 SRAM 与 DRAM

| 特点类型   | SRAM   | DRAM                                     |
| ---------- | ------ | ---------------------------------------- |
| 存储信息   | 触发器 | 栅极电容上的电荷                         |
| 破坏性读出 | 非     | 是                                       |
| 需要刷新   | 不要   | 需要                                     |
| 送行列地址 | 同时送 | 分两次送(地址复用技术)，分行、列两次传送 |
| 运行速度   | 快     | 慢                                       |
| 集成度     | 低     | 高(只有一个晶体管)                       |
| 发热量     | 大     | 小                                       |
| 存储成本   | 高     | 低                                       |
| 常用作     | Cache  | 主存                                     |

### 3.3.2 DRAM的刷新

> ​	DRAM电容上的电荷一般只能维持1~2ms，每隔一段时间要刷新，通常取2ms，称为刷新周期，刷新周期通常取整数。

1. 分散刷新 : 每次读写完都刷新一行，存取周期一段用来读写，一段用来刷新，不存在死时间，但是存取周期变长。

	![image-20210420225608967](http://cdn.zhouxug.cn/20210420225609.png)

2. 集中刷新  : 2ms内集中安排时间全部刷新，存在一段死时间

	![image-20210420225619823](http://cdn.zhouxug.cn/20210420225619.png)

3. 异步刷新 : 2ms内每行刷新一次即可,刷新时间除以行数，每过一小段时间刷新一次，缩短了死时间，但死时间仍然存在。

![image-20210420225732426](http://cdn.zhouxug.cn/20210420225732.png)

**补充：**

​	刷新时是把信息读出，通过一个刷新放大器后又重新存回储存单元，刷新放大器集成在DRAM上，所以*刷新只进行了一次访存，只有一个存取周期*。

### 3.3.3 存储芯片内部结构

![image-20210422200726027](http://cdn.zhouxug.cn/20210422200726.png)

1. 存储体：存储单元的集合，由行选择线X和列选择线Y构成，存储体上相同行列上的位同时被读出/写入
2. 地址译码器
3. IO控制电路：具有放大信息的作用
4. 片选控制信号：扩展芯片访问某个字时，通过片选信号选中该存储字所在的芯片
5. 读写控制信号：**可以读写共同一根，也可以两根，看题目要求**

### *3.3.4 补充：芯片的引脚数目

#### 1. 1024\*8位的SRAM芯片为例，除去电源线和接地线 (P99,1)

1. 地址线：10根，芯片1024B，2<sup>10</sup> = 1024。

2. 数据线：8根，字节编址对应8位。 
3. 片选线：1根
4. 读写控制线：1 / 2根

#### 2. 4M\*8位的DRAM，除去电源线和接地线  (p100,10)

1. 地址线：5根，**DRAM可以使用地址复用技术，则只需要5根地址线，地址分两次传输**
2. 数据线：8根
3. 行通选和列通选线：2根 **片选线用行通线代替**
4. 读写控制线：1 / 2根

### 3.3.5 存储器的读写周期

#### 1. RAM的读周期

​		给出有效地址开始，到读出所选中单元的内容并在外部数据总线上稳定地出现所需的时间，称为读出时间 t<sub>A</sub>。地址片选信号 $\overline{CS}$ 必须保持到数据稳定输出，t<sub>co</sub>为片选的保持时间， 在读周期中$\overline{WE}$为高电平。 读周期与读出时间是两个不同的概念，读周期时间 t<sub>RC</sub>表示存储芯片进行两次连续读操作时所必须间隔的时间，它总是大于等于读出时间。

![image-20210422204014182](https://cdn.zhouxug.cn/20210422204014.png)

#### 2. RAM的写周期

​		要实现写操作，要求片选信号$\overline{CS}$和写命令信号$\overline{WE}$必须都为低电平。为使数据总线上的信息能够可靠地写入存储器，要求$\overline{CS}$信号与$\overline{WE}$信号相"与"的宽度至少为t<sub>w</sub>。 为了保证在地址变化期间不会发生错误写入而破坏存储器的内容，$\overline{WE}$信号在地址变化期间必须为高电平。为了保证有效数据的可靠写入，地址有效的时间至少应为 t<sub>wc</sub> = t<sub>Aw</sub>＋t<sub>w</sub>+ t<sub>wR</sub>。为了保证在$\overline{WE}$和$\overline{CS}$变为无效前能把数据可靠地写入，要求写入的数据必须在 t<sub>Dw</sub>以前在 数据总线上已经稳定。

![image-20210422204504333](http://cdn.zhouxug.cn/20210422204504.png)

### 3.3.6 主存储器的基本组成

​	指令执行过程中需要访问主存时，CPU 首先把被访问单元的地址送到 MAR 中，然后通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码选中相应单元，同时CPU 将读写信号通过控制线送到主存的读写控制电路。

​	如果是写操作，那么 CPU 同时将要写的信息送到 MDR 中，在读写控制电路的控制下，经数据线将信号写入选中的单元；如果是读操作，那么主存读出选中单元的内容送到数据线，然后送到 MDR 中。数据线的宽度与 MDR 的宽度相同，地址线的宽度与 MAR 的宽度相同。图 3.7 采用 64 位数据线，所以在按字节编址方式 下，每次最多可以存取 8 个单元的内容。地址线的位数决定了主存地址空间的最大可寻址范围。例如，36 位地址的最大寻址范围为0～2*-1，即地址从0开始编号。

![image-20210422205541825](http://cdn.zhouxug.cn/20210422205541.png)

​	数据线数和地址线数共同反映存储体容量的大小，图3.7中芯片的容量=2<sup>23</sup>×64 位。

**补充：**

​		计算时，用作速率时，1K = 1000，用作容量时，1K = 1024

# 3.4 主存储器与CPU的连接

### 3.4.1 连接原理

1. 主存储器通过数据总线、地址总线和控制总线 数据总线 与 CPU 连接。 
2. 数据总线的位数与工作频率的乘积正比于数据传输率。
3. 地址总线的位数决定了可寻址的最大内存空间。
4. 控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻。

<img src="http://cdn.zhouxug.cn/20210422223924.png" alt="image-20210422223924576" style="zoom:80%;" />

MDR：存储数据寄存器，存放读出或写入的信息

MAR：存储地址寄存器，**要保证能够访问到整个主存**

### 3.4.2 主存容量的扩展

#### 1. 位扩展法

​		CPU 的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。**多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。**

​		**仅采用位扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同，在某 一时刻选中所有的芯片，所以片选信号CS要连接到所有芯片。**

<img src="http://cdn.zhouxug.cn/20210422225056.png" alt="image-20210422225056778" style="zoom:80%;" />

#### 2. 字扩展法

​		字扩展是指增加存储器中字的数量，而位数不变。**字扩展将芯片的地址线、数据线、读写 控制线相应并联，而由片选信号来区分各芯片的地址范围。**

​		**仅采用字扩展时，各芯片连接地址线的方式相同，连接数据线的方式也相同，但在某一时刻只需选中部分芯片，所以通过片选信号CS或采用译码器设计连接到相应的芯片。**

<img src="http://cdn.zhouxug.cn/20210422225111.png" alt="image-20210422225111768" style="zoom:80%;" />

#### 3. 字位同时扩展法

​		**采用字位同时扩展时，各芯片连接地址线的方式相同，但连接数据线的方式不同， 而且需要通过片选信号CS或采用译码器设计连接到相应的芯片。**

<img src="http://cdn.zhouxug.cn/20210422225145.png" alt="image-20210422225144943" style="zoom:80%;" />

### 3.4.3 存储芯片的地址分配和片选

> ​		片内的字选通常是由 CPU 送出 的 N条低位地址线完成的，地址线直接接到所有存储芯片的地址输入端（N由片内存储容量 2* 决定）。片选信号的产生分为线选法和译码片选法。

#### 1. 线选法

​		线选法用除片内寻址外的高位地址线直接（或经反相器）分别接至各个存储芯片的片选 端，当某地址线信息为"0"时，就选中与之对应的存储芯片。**一位对应一片**

- 优点：不需要地址译码器，线路简单。
- 缺点： 地址空间不连续，不能充分利用系统的存储器空间，造成地址资源的浪费。
- ![](http://cdn.zhouxug.cn/20210422225640.png)

#### 2. 译码片选法

​		译码片选法用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号。**一个值对应一片**

### 3.4.4 存储器与CPU的连接

#### 1. 地址线的连接

​		CPU地址线的低位与存储芯片的地址线相连，以选择芯片中的某一单元（字选）， 这部分的译码是由芯片的片内逻辑完成的。而 CPU 地址线的高位则在扩充存储芯片时使用，用来选择存储芯片（片选），这部分译码由外接译码器逻辑完成。

#### 2. 数据线的连接

​		CPU 的数据线数与存储芯片的数据线相等时可直接相连，在不等时必须对存储芯片扩位，使其数据位数与 CPU 的数据线数相等。

#### 3. 读写命令的连接

​		CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，通常**高电平为读，低电平为**写。有些 CPU 的读/写命令线是分开的（读为RD，写为WE，均为低电平有效），此时CPU的 读命令线应与存储芯片的允许读控制端相连，而 CPU 的写命令线则应与存储芯片的允许写控制端相连。

#### 4. 片选线的连接

​		片选有效信号与 CPU 的访存控制信号$\overline{MREO}$（低电平有效）有关，因为只有当 CPU 要求访存时，才要求选中存储芯片。若 CPU访问I/O，则$\overline{MREO}$为高，表示不要求存储器工作。

# 3.5 双端口 RAM和多模块存储器

### 3.5.1 双端口RAM  / 空间并行

> ​		双端口 RAM 是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址 线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元.

<img src="http://cdn.zhouxug.cn/20210426194932.png" alt="image-20210426194932180" style="zoom:80%;" />

**错误情况**：

1. 两个端口同时对同一地址单元写入数据   *写入错误*
2. 两个端口同时对同一地址单元操作，一个写入数据，另一个读出数据  *读出错误*

**解决方法∶** 

​		置"忙"信号$\overline{BUSY}$为 0，由判断逻辑决定暂时关闭一个端口（即被延时），未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。

### 3.5.2 多模块存储器

#### 1. 单体多字存储器

> ​		特点是存储器中只有一个存储体，每个存储单元存储 m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。

<img src="http://cdn.zhouxug.cn/20210426200011.png" alt="image-20210426200011360" style="zoom:80%;" />

- 优点：这增大了存储器的带宽，提高了单体存储器的工作速度。
- 缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存 放，这种方法的效果就不明显。

#### 2. 多体并行存储器

> ​		由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。

##### 1. 高位交叉编址 / 顺序方式

​		访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问， **CPU 总是按顺序访问存储模块，存储模块不能被并行访问，因而不能提高存储器的吞吐率。**模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器。

<img src="http://cdn.zhouxug.cn/20210426200546.png" alt="image-20210426200546412" style="zoom:80%;" />

##### 2. 低位交叉编址 / 交叉方式 

​		程序连续存放在相邻模块中，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。

 **计算题！！！**

​		模块字长等于数据总线宽度，模块存取一个字的存取周期为 T，总线传送周期为r，为实 现流水线方式存取，存储器交叉模块数应大于等于 

​													**m = T / r**

​		m称为交叉存取度。每经过r时间延迟后启动下一个模块，交叉存储器要求其模块数必须大于等于 m，以保证启动某模块后经过 m * r的时间后再次启动该模块时，其上次的存取操作已经完成（即流水线不间断）。

​		连续存取m个字所需的时间为   t<sub>1</sub>  = T+(m-1)  

​		而顺序方式连续读取m个字所需的时间为 t<sub>2</sub>= m * T 

<img src="http://cdn.zhouxug.cn/20210426201126.png" alt="image-20210426201126934" style="zoom:50%;" />

​		模块数为 4 的流水线方式存取如图

<img src="http://cdn.zhouxug.cn/20210426201606.png" alt="image-20210426201606915" style="zoom: 80%;" />

**注：**

1. 高位交叉编制并不能很好的满足程序的局部性原理，因为他不能连续存取，**一次连续读出彼此相差一个存储体人容量的机会很少**；低位交叉编址则可以满足局部性原理，提高带宽。
2. 低位交叉编址和多端口存储器比较：
	1. 四端口容量拓展较为困难
	2. 多端口存储器不能同时执行多个写入操作，而多体结构可以在一个存储周期内对不同存储体进行写入操作

# 3.6 Cache 

### 3.6.1 程序访问的局部性原理

- 空间局部性：在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放的，数据一般也是以向量、数组等形式存储在一起的。

- 时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息，比如循环。

​       **即程序对存储系统的访问是不均匀的**

​        Cache利用程序访问的局部性原理，把程序中正在使用的部分存放在一个高速 的、容量较小的 Cache 中。

### 3.6.2 Cache基本工作原理 

​		CPU 与 Cache 之间的数据交换以字为单位，Cache 和主存都被划分为相等的块，数据交换以 Cache 块为单位。

​		在CPU发出读请求时，有的计算机是先访问Cache，在访问主存；有的则是同时访问，若Cache命中，主存终止访问。

​		Cache 的总命中次数为N<sub>c</sub>，访问主存的总次数为N<sub>m</sub>，则命中率H为

​																**H= N<sub>c</sub>/(N<sub>c</sub>＋N<sub>m</sub>)**

​		设t<sub>c</sub>为命中时的 Cache访问时间，t<sub>m</sub>为未 命中时的访问时间，则Cache-主存系统的平均访问时间T<sub>a</sub>为

​													       	**T<sub>a</sub>=H * t<sub>c</sub>+(1-H) * t<sub>m</sub>**

​		访问效率

​																**e = t<sub>c</sub> / t <sub>a</sub>**

**补充**：

​		**指令Cache与数据Cache相分离，是为了避免资源冲突**，在五级指令流水线中，分为IF(取址)，ID(译码)，EXE(执行)，MEM(访存)，WB(写回)。其中IF和MEM都会访问cache。但是IF访问cache是取指令，MEM访问内存是取数据。当前指令的MEM和后面指令IF同时在流水线上执行，会产生同时访问Cache的冲突(资源冲突)，分开可以提高流水线效率。

### 3.6.3 Cache和主存的映射方式

#### 1. 直接映射

> ​		主存中的每一块只能装入 Cache 中的唯一位置。若这个位置已有内容，则产生冲突，原来的块将无条件地被替换出去（无须使用替换算法）。

- 优点：实现简单
- 缺点：不够灵活，即使 Cache 的其他许多地址空着也不能占用，这使得**直接映射的块冲突概率最高，空间利用率最低。**

主存地址格式：

![image-20210426204359771](http://cdn.zhouxug.cn/20210426204359.png)

访存过程：

​		首先根据访存地址中间的c位，找到对应的 Cache 行，将对应 Cache 行中的标记和主存地址的高t位标记进行比较，若相等且有效位为 1，则访问 Cache "命中"，此时根据主存地址中低位的块内地址，在对应的 Cache 行中存取信息；若不相等或有效位为 0，则"不命中"，此时 CPU 从主存中读出该地址所在的一块信息送到对应的 Cache 行中，将有效位置1，并将标记设置为地址中的高1位，同时将该地址中的内容送CPU。

#### 2. 全相联映射

> ​		主存中的每一块可以装入 Cache 中的任何位置，每行的标记用于指出该行取自主存的哪一 块，所以 CPU 访存时需要与所有 Cache 行的标记进行比较。

- 优点：比较灵活，Cache 块的冲突概率低，空间利用率高，命中率也高
- 缺点：是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射。

主存地址格式：

![image-20210426204606306](http://cdn.zhouxug.cn/20210426204606.png)

#### 3. 组相联映射

> ​		将 Cache 空间分成大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即 组间采取直接映射，而组内采取全相联映射.
>
> ​		假设每组有r个 Cache行，则称之为r路组相联，

​		选定适当的路数，可使组相联映射的成本接近直接映射，而性能上仍接近全相联映射。

主存地址格式：

​		![image-20210426205324607](http://cdn.zhouxug.cn/20210426205324.png)

访存过程：

​		首先根据访存地址中间的组号找到对应的 Cache 组，将对应 Cache 组中每个行的标记与主存地址的高位标记进行比较;若有一个相等且有效位为1，则访问 Cache 命中；若都不相等或虽相等但有效位为0，则不命中，此时 CPU 从主存中读出该地址所在的一块信息送到对应 Cache 组的任意一个空闲行中，将有效位置 1，并设置标记，同时将该地址中的内容送 CPU。

#### 4. Cache行容量

​		Cache由标记项和数据构成，标记项包含：

1. 有效位：**一定有**
2. 标记位：**一定有**
3. 一致维护位 / 脏位：**可能有**
4. 替换算法控制位：**可能有**

<img src="http://cdn.zhouxug.cn/20210426205846.png" alt="image-20210426205846945" style="zoom:80%;" />

**补充：**

当Cache大小、主存块大小一定时：

1. 直接映射的命中率最低，全相联映射的命中率最高。 
2. 直接映射的判断开销最小、所需时间最短，全相联映射的判断开销最大、所需时间最长。 
3. 直接映射标记所占的额外空间开销最少，全相联映射标记所占的额外空间开销最大。

### 3.6.4 Cache 中主存块的替换算法

#### 1. LRU / 近期最少使用算法∶

> ​		依据程序访问的局部性原理，选择近期内长久未访问过的 Cache行作为替换的行，平均命中率要比 FIFO 的高，是堆栈类算法。

**例：**

​		采用4路组相联,左边阴影的数字是对应 Cache 行的计数值，右边的数字是存放在该行中的主存块号。

![image-20210426210927289](http://cdn.zhouxug.cn/20210426210927.png)

计数器的变化规则∶

1. 命中时，所命中的行的计数器清零，**比其低的计数器加 1**，其余不变
2. 未命中且还有空闲行时，新装入的行的计数器置 0，其余全加 l
3. 未命中且无空闲行 时，计数值为3的行的信息块被淘汰，新装行的块的计数器置 0，其余全加1。

这样可以保证，若该Cache组全满时，计数值总为0，1，2，3

**抖动：**

​		当集中访问的存储区超过 Cache 组的大小时，命中率可能变得很低，如上例的访问序列变 为1，2，3，4，5，1，2，3，4，5，…，而 Cache每组只有4行，那么命中率为0。

#### 2. 最不经常使用算法

> ​		将一段时间内被访问次数最少的存储行换出，但无法找出最近最少访问的存储体。
>
> ​		如有个存储体很久未被访问，最近一直被访问，但由于总值很低，仍会被换出。

### 3.6.5 Cache写策略

#### 1. 全写法 / 直通法

> ​		当 CPU 对 Cache写命中时，必须把数据同时写入 Cache 和主存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。

- 优点：实现简单，能随时保持主存数据的正确性
- 缺点：是增加了访存次数，降低了Cache 的效率。

写缓冲：

​		为减少全写法直接写入主存的时间损耗，在 Cache和主存之间加一个写缓冲，CPU 同时写数据到 Cache 和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个 FIFO 队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。

![image-20210426211825229](http://cdn.zhouxug.cn/20210426211825.png)

#### 2. 写回法

> ​		当CPU对Cache写命中时，只修改 Cache的内容，而不立即写入 主存，只有当此块被换出时才写回主存。每个 Cache 行必须设置一个标志位（脏位），以反映此块是否被 CPU 修改过。

- 优点：减少了访存次数
- 缺点：存在不一致的隐患



**全写法和写回法均为写命中时**

#### 3. 写不命中

1. 写分配法：加载主存中的块到 Cache 中，然后更新这个 Cache块。它试 图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。
2. 非写分配法：只写入主存，不进行调块。

**非写分配法通常与全写法合用，写分配法通常和写回法合用。**

#### 4. 多级Cache

> ​		按离CPU的 远近可各自命名为L1 Cache、L2 Cache、L3 Cache，离 CPU越远，访问速度越慢，容量越大。 指令 Cache 与数据Cache 分离一般在L1 级，此时通常为写分配法与写回法合用。

**例**：

​		下图是一个含有两级 Cache 的系统，L1 Cache对L2 Cache使用全写法，L2 Cache对主存使用写回法，由于L2 Cache的存在，其访问速度大于主存，因此写缓冲队列基本不会阻塞，避免了因频繁写时造成的写缓冲饱和溢出。

![image-20210426213505253](http://cdn.zhouxug.cn/20210426213505.png)



# 3.7 虚拟存储器

### 3.7.1 基本概念

#### 1. 背景

​		希望在编制程序时独立编址，既不考虑程序能否在物理存储器中是否存放的下，也不考虑程序应该放在什么位置。而在程序运行时，分配给每个程序一定的运行空间，由地址转换部件将编程时的地址转换成实际内存的物理地址。若分配的内存不够，则只调入当前正在运行的或将要运行的程序或数据块，其余部分暂时驻留在辅存中。

#### 2. 概念

​		用户编程允许涉及的地址称为**虚地址或逻辑地址**，虚地址对应的存储空间称为**虚存空间或逻辑空间**。实际的主存单元地址称为**实地址或物理地址**，实地址对应的是**物理存储空间或主存空间**。

​		**虚存空间可以大于主存空间，也可以小于主存空间：**

1. 大于时，以提高存储容量为目的
2. 小于时，则以地址变换为目的，通常出现在多用户或多任务系统中：主存空间大，单个任务并不需要很大的地址空间，较小的虚存空间可以缩短指令中地址字段的长度。

### 3.7.2 页式虚拟存储器

> 以页为基本单位的虚拟存储器称为页式虚拟存储器。

1. **虚拟空间与主存空间都被划分成同样大小的页**，主存的页称为实页，虚存的页称为虚页
2. 把虚拟地址分为两个字段∶虚页号和页内地址。
3. 虚拟地址到物理地址的转换是由页表实现的。页表是一张存放在主存中的虚页号和实页号的对照表，它记录程序的虚页调入主存时被安排在主存中的位置。**页表一般长久地保存在内存中。**

#### 1. 页表

​		页表通常包含：

1. 有效位(装入位)，用来表示对应页面是否在主存，若为1，则表示该虚拟页已从外存调入主存，**此时页表项存放该页的物理页号**；若为0，则表示没有调入主存，**此时页表项可以存放该页的磁盘地址**。
2. 脏位(修改位)，用来表示页面是否被修改过，**虚存机制中采用回写策略**，利用脏位可判断替换时是否需要写回磁盘。
3. 引用位(使用位)，用来配合替换策略进行设置，例如FIFO或LRU策略等。

![image-20210427213516598](http://cdn.zhouxug.cn/20210427213516.png)

​		 CPU执行指令时，需要先将虚拟地址转换为**主存物理地址**。**每个进程对应一个页表**，页表基址寄存器存放该进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项，若装入位为 1，则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址；若装入位为 0，则说明缺页，需要操作系统进行缺页处理。

<img src="http://cdn.zhouxug.cn/20210427213812.png" alt="image-20210427213812637" style="zoom: 80%;" />

- 优点：页面的长度固定，页表简单，调入方便。
- 缺点：最后一页的零头将无法利用而造成浪费；并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。

#### 2. 快表 / TLB   (相联存储器实现)

​		访存时要先去主存寻找页表，再访问主存取得数据，即一次访存至少要访问2次主存。

​		把经常访问的页放在高速缓存组成的快表(TLB)里，在地址转换时，首先查找快表，若命中，则无须访问主存中的页表(慢表)。这样就减少查询物理地址时访问主存频率。

​		快表通常采用全相联或组相联方式。

**注：页表中有有效位，其页面可能不在主存中，在辅存中，而TLB中的页面由页表装入，所以对应页面全部都在主存中。**

#### 3. TLB和Cache组成的多级缓存结构

​		访存时，CPU首先给出虚拟地址，与TLB进行比较，若命中则转换为物理地址；若未命中则TLB缺失，需要访问主存查找页表，若页表命中，则转换物理地址，**并将相应表项调入TLB中**；若未命中，则进行缺页处理，从磁盘读出一页到主存，**更新页表和TLB**。转换为物理地址后，比较对应主存块是否在Cache中，若命中则通过Cache访问数据；若未命中，则将该主存块送入Cache并置标记和有效位，再访问Cache存取数据。

![image-20210427224335953](http://cdn.zhouxug.cn/20210427224336.png)

​		下图为一个具有TLB和Cache 的多级存储系统实例。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与 每个TLB标记字段同时进行比较。图中所示的是两级页表方式，虚页号被分成页目录索引和页表索引两部分，由这两部分得到对应的页表项，从而进行地址转换，并将相应表项调入TLB，若TLB已满，则还需要采用替换策略。Cache采用二路组相联方式，根据组号和标记确定数据。

![image-20210427221952196](http://cdn.zhouxug.cn/20210427221952.png)

​		查找时，快表和慢表可同步进行，若快表中有此虚页号，则能很快地找到对应的实页号，并使慢表的查找作废，从而就能做到虽采用虚拟存储器但访问主存速度几乎没有下降。

#### 4. TLB、Page、Cache 缺失组合情况

1. TLB 缺失∶要访问的页面对应的页表项不在 TLB 中。
2. 页表(Page)缺失∶要访问的页面不在主存中。
3. Cache 缺失∶要访问的主存块不在 Cache 中。

<img src="http://cdn.zhouxug.cn/20210427222254.png" alt="image-20210427222254625"  />

​		TLB命中则Page一定命中，所以不可能出现TLB缺失而Page命中的情况；

​		Page缺失则Cache一定缺失，页不在内存，Cache不可能有数据。

#### 5. 补充：

​		页面不能过大或过小

1. 过大会导致装入页面变慢，并且增大内存碎片
2. 过小会导致页表变长，占据内存容量过多。

### 3.7.3 段式虚拟存储器

1. 段是按程序的逻辑结构划分的，各个段的长度因程序而异
2. 把虚拟地址分为两部分∶段号和段内地址。
3. 虚拟地址到实地址之间的变换是由段表来实现的。段表是程序的逻辑段和在主存中存放位置的对照表.
4. 段表的每行记录包括**装入位、段首址和段长**等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。
5. **每个程序对应一个段表**

<img src="http://cdn.zhouxug.cn/20210427225645.png" alt="image-20210427225645822" style="zoom:80%;" />

​		CPU 根据虚拟地址访存时，首先根据段号与段表基地址拼接成对应的段表行，然后根据该段表行的装入位判断该段是否已调入主存。已调入主存时，**则将虚拟地址的段内偏移量与段长进行比较，若偏移量较大则说明地址越界，产生越界中断**。否则，从段表读出该段在主存中的起始地址，与段内地址（偏移量）相加，得到对应的主存实地址。

- 优点：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享。
- 缺点：因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。

### 3.7.4 段页式虚拟存储器

1. 把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页， 程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。
2. 在段页式虚拟存储器中，**每个程序对应一个段表**，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。
3. 虚地址分为段号、段内页号、页内地址三部分。CPU 根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。

### 3.7.5 虚存与Cache的区别

#### 1. Cache - 主存与主存 - 辅存结构

1. Cache与主存间由辅助硬件负责地址变换与管理，构成了系统的内存
2. 主存与辅存间由辅助软硬件负责地址变换与管理，构成了虚拟存储器

#### 2. Cache - 主存与主存 - 辅存相同点

1. 出发相同：提高存储系统的性价比而构造的分层存储结构
2. 原理相同：利用程序的局部性原理，把最常用的信息块从慢速大容量的存储器调入快速小容量的存储器

#### 3. Cache - 主存与主存 - 辅存不相同点

1. 侧重点不同：Cache主要解决主存与CPU的速度差异，虚存主要解决存储容量问题。
2. 数据通路不同：CPU与Cache有直接的数据访问通路，而辅存与CPU间没有直接的数据通路，当主存不命中时必须使用调页解决，CPU最终还是要访问主存。
3. 透明性不同：Cache全部由硬件完成，对系统程序员和应用程序员均透明，而虚存由操作系统和硬件共同完成，所以对系统程序员不透明，只对应用程序员透明。（段式和段页式对应用程序员半透明）
4. 未命中时损失不同：Cache比主存快5-10倍，而主存比辅存快上千倍，所以主存未命中性能损失远大于Cache未命中损失。




































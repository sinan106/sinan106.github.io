<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-综述"><a href="#1-综述" class="headerlink" title="1. 综述"></a>1. 综述</h1><blockquote><p>软件设计模式使人们可以更加简单方便复用成功的设计和体系结构</p></blockquote><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><blockquote><p>设计模式有两种分类方法，一种根据模式的目的来分；另一种根据模式的作用来分。</p></blockquote><p><img src="http://cdn.zhouxug.cn/20201024215450.png" alt="image-20201024215450877"></p><h3 id="2-23种设计模式概述"><a href="#2-23种设计模式概述" class="headerlink" title="2. 23种设计模式概述"></a>2. 23种设计模式概述</h3><ol><li>单例（Singleton）模式</li></ol><p>某个类只能生成一个实例，该类提供了一个全局访问点，供外部获取该实例，其拓展是有限多个实例。</p><ol start="2"><li>原型（Prototype）模式</li></ol><p>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p><ol start="3"><li>工厂方法（Factory Method）模式</li></ol><p>定义一个用户创建产品的接口，有子类决定生产什么产品。</p><ol start="4"><li>抽象工厂（Abstract Factory）模式</li></ol><p>提供一个创建产品族的接口，其每个子类可以生产一些列相关的产品。</p><ol start="5"><li>建造者（Builder）模式</li></ol><p>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p><ol start="6"><li>代理（Proxy）模式</li></ol><p>为某个对象提供一种代理以控制对对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特征。</p><ol start="7"><li>适配器（Adapter）模式</li></ol><p>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><ol start="8"><li>桥接（Bridge）模式</li></ol><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低 抽象和实现这两个可变维度的耦合度。<br>9. 装饰（Decorator）模式</p><p>动态的给对象增加一些职责，即增加其额外的功能。<br>10. 外观（Face）模式</p><p>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p><ol start="11"><li>享元（Flyweight）模式</li></ol><p>运用共享技术来有效地支持大量细粒度对象的复用。</p><ol start="12"><li>组合（Composite）模式</li></ol><p>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p><ol start="13"><li>模板方法（Template Method）模式</li></ol><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特点步骤。</p><ol start="14"><li>策略（Strategy）模式</li></ol><p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响算法的客户。</p><ol start="15"><li>命令（Command）模式</li></ol><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p><ol start="16"><li>职责链（Chain of Responsibility）模式</li></ol><p>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这个方式去除对象之间的耦合。</p><ol start="17"><li>状态（State）模式</li></ol><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p><ol start="18"><li>观察者（Observer）模式</li></ol><p>多个对象间存在一对多的关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其它对象的行为。</p><ol start="19"><li>中介者（Mediator）模式</li></ol><p>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象的耦合度，使原有对象之间不必户互了解。</p><ol start="20"><li>迭代器（Iterator）模式</li></ol><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p><ol start="21"><li>访问者（Visitor）模式</li></ol><p>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象。</p><ol start="22"><li>备忘录（Memento）模式</li></ol><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后回复它。</p><ol start="23"><li>解释器（Interpreter）</li></ol><p>提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p><h1 id="2-创建型设计模式"><a href="#2-创建型设计模式" class="headerlink" title="2. 创建型设计模式"></a>2. 创建型设计模式</h1><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><blockquote><p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p></blockquote><p>单例模式有以下3个特点：</p><ol><li><p>单例类只有一个对象；</p></li><li><p>该单例对象必须由单例类自行创建；</p></li><li><p>单例类对外提供一个访问该单例的全局访问点。</p></li></ol><h4 id="1-1-单例模式的结构与实现"><a href="#1-1-单例模式的结构与实现" class="headerlink" title="1.1 单例模式的结构与实现"></a>1.1 单例模式的结构与实现</h4><blockquote><p>通常，普通类的结构函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法通过调用该类的构造函数，也就无法生成多个实例。这是该类自身必须定义一个静态私有实例，并向外提供一个讲台的公有函数用于创建或获取静态私有实例。</p></blockquote><p>下面分析单例模式的实现。</p><p>单例模式有懒汉式和饿汉式两种实现形式。</p><h5 id="1-1-1-懒汉式"><a href="#1-1-1-懒汉式" class="headerlink" title="1.1.1 懒汉式"></a>1.1.1 懒汉式</h5><blockquote><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getInstance() 方法才去创建单例。代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</u></p><h5 id="1-1-2-饿汉式"><a href="#1-1-2-饿汉式" class="headerlink" title="1.1.2 饿汉式"></a>1.1.2 饿汉式</h5><blockquote><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>饿汉式单例在类 创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，以后线程安全的，可以直接用于多线程而不会出现问题。</u></p><h4 id="1-2-单例模式的应用场景"><a href="#1-2-单例模式的应用场景" class="headerlink" title="1.2 单例模式的应用场景"></a>1.2 单例模式的应用场景</h4><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul><h4 id="1-3-单例模式的拓展"><a href="#1-3-单例模式的拓展" class="headerlink" title="1.3 单例模式的拓展"></a>1.3 单例模式的拓展</h4><blockquote><p>单例模式可扩展为有效的多例（Multiple）模式，这种模式可以生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取，其结构如图2-1所示。</p></blockquote><p><img src="http://cdn.zhouxug.cn/20201024221526.png" alt="image-20201024221526320"></p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML</title>
      <link href="2020/10/24/UML/"/>
      <url>2020/10/24/UML/</url>
      
        <content type="html"><![CDATA[<h1 id="UML概念"><a href="#UML概念" class="headerlink" title="UML概念"></a>UML概念</h1><blockquote><p>UML是Unified Model Language的缩写，中文是统一建模语言，是由一整套图表组成的标准化建模语言。</p></blockquote><p>UML分类：</p><ul><li>结构图分为类图、轮廓图、组件图、组合结构图、对象图、部署图、包图。</li><li>行为图又分活动图、用例图、状态机图和交互图。</li><li>交互图又分为序列图、时序图、通讯图、交互概览图。</li></ul><img src="http://cdn.zhouxug.cn/20201024201343.png" alt="image-20201024201343588" style="zoom: 67%;" /><h1 id="UML各类图"><a href="#UML各类图" class="headerlink" title="UML各类图"></a>UML各类图</h1><h3 id="1-类图"><a href="#1-类图" class="headerlink" title="1. 类图"></a>1. 类图</h3><blockquote><ul><li>【概念】 类图是一切面向对象方法的核心建模工具。类图描述了系统中对象的类型以及它们之间存在的各种静态关系。</li><li>【目的】用来表示类、接口以及它们之间的静态结构和关系。</li></ul></blockquote><ol><li>泛化</li></ol><ul><li>【泛化关系】是一种<strong>继承关系</strong>，表示子类继承父类的所有特征和行为。</li><li>【箭头指向】带三角箭头的实线，箭头指向父类。</li></ul><p><img src="http://cdn.zhouxug.cn/20201024201716.png" alt="image-20201024201716514"></p><ol start="2"><li>实现</li></ol><ul><li>【实现关系】是一种<strong>类与接口的关系</strong>，表示类是接口所有特征和行为的实现。</li><li>【箭头指向】带三角箭头的虚线，箭头指向接口</li></ul><p><img src="http://cdn.zhouxug.cn/20201024201755.png" alt="image-20201024201755548"></p><ol start="3"><li>关联</li></ol><ul><li>【关联关系】是一种<strong>拥有关系，它使得一个类知道另一个类的属性和方法</strong>。</li><li>【代码体现】成员变量</li><li>【箭头指向】带普通箭头的实线，<strong>由拥有者出发，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。</strong>单向的关联有一个箭头。</li></ul><p><img src="http://cdn.zhouxug.cn/20201024201819.png" alt="image-20201024201819861"></p><p><u>    自己买的车，想什么时候开就开。但是车是车，人是人，没有整体与部分的关系。</u></p><ol start="4"><li>聚合</li></ol><ul><li>【聚合关系】是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是<strong>关联关系的一种</strong>，<strong>是强的关联关系；</strong>关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</li><li>【代码体现】成员变量</li><li>【箭头指向】带空心菱形的实线，空心菱形指向整体。</li></ul><p><img src="http://cdn.zhouxug.cn/20201024202046.png" alt="image-20201024202046020"></p><p><u>    电脑有键盘才能输入信息，电脑是整体，键盘是部分，键盘也可以离开电脑，单纯的拿去敲。所以是聚合。</u></p><ol start="5"><li>组合</li></ol><ul><li>【组合关系】是一种整体与部分的关系。但部分不能离开整体而单独存在，<strong>组合关系是关联关系的一种，是比聚合关系还要强的关系。</strong></li><li>【代码体现】成员变量</li><li>【箭头指向】带实心菱形的实线，实心菱形指向整体。</li></ul><p><img src="http://cdn.zhouxug.cn/20201024202652.png" alt="image-20201024202652563"></p><p><u>    鸟是整体，翅膀是部分。鸟死了，翅膀也就不能飞了。所以是组合。</u></p><p><img src="http://cdn.zhouxug.cn/20201024202816.png" alt="image-20201024202816386"></p><p><u>    一个公司拥有多个部门，公司和部门之间是组合关系，公司破产了，部门就不复存在了。部门和员工是<strong>聚合关系，部门被裁掉，员工就换下家了</strong>。</u></p><ol start="6"><li>依赖</li></ol><ul><li>【依赖关系】是一种使用关系，即一个类的实现需要另一个类的协助。</li><li>【箭头指向】带普通箭头的虚线，<strong>由使用者出发，指向被使用者。</strong></li></ul><p><img src="http://cdn.zhouxug.cn/20201024202947.png" alt="image-20201024202947444"></p><p><u>    老司机只管开车，车是谁的不重要，给什么车开什么车。</u></p><h3 id="2-对象图"><a href="#2-对象图" class="headerlink" title="2. 对象图"></a>2. 对象图</h3><blockquote><ul><li>【概念】<strong>对象图是类图的一个实例</strong>，是系统在某个时间点的详细状态的快照。</li><li>【目的】用来表示两个或者多个对象之间在某一时刻之间的关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024205006.png" alt="image-20201024205006239"></p><p><u>    某时间点bat这个公司有一个研发部，一个销售部，两个部门只有一个人iisheng</u></p><h3 id="3-用例图"><a href="#3-用例图" class="headerlink" title="3. 用例图"></a>3. 用例图</h3><blockquote><ul><li>【概念】用例图是指由参与者、用例，边界以及它们之间的关系构成的用于描述系统功能的视图。</li><li>【目的】用来描述整个系统的功能。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024205223.png" alt="image-20201024205223259"></p><p>用例图中包含以下三种关系：</p><ul><li>包含关系使用符号《include》，想要查看订单列表，前提是需要先登录。</li><li>扩展关系使用符号《extend》，基于查询订单列表的功能，可以增加一个导出数据的功能</li><li>泛化关系，子用例继承父用例所有结构、行为和关系。</li></ul><h3 id="4-序列图"><a href="#4-序列图" class="headerlink" title="4. 序列图"></a>4. 序列图</h3><blockquote><ul><li>【概念】序列图根据时间序列展示对象如何进行协作。它展示了在用例的特定场景中，对象如何与其他对象交互。</li><li>【目的】通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024205553.png" alt="image-20201024205552968"></p><p><u>    图中展示的是支付宝条码支付场景的序列图。其中，loop是循环，alt是选择。</u></p><h3 id="5-通讯图"><a href="#5-通讯图" class="headerlink" title="5. 通讯图"></a>5. 通讯图</h3><blockquote><ul><li>【概念】描述了收发消息的对象的组织关系，强调<strong>对象之间的合作关系</strong>而不是时间顺序。</li><li>【目的】用来显示不同对象的关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024205803.png" alt="image-20201024205803312"></p><p><u>    图中展示了一个线上书店的通讯图，方框和小人表示生命线，不同生命线之间可以传递消息，消息前面的数字可以表达序列顺序。</u></p><h3 id="6-交互概览图"><a href="#6-交互概览图" class="headerlink" title="6. 交互概览图"></a>6. 交互概览图</h3><blockquote><ul><li>【概念】交互概览图与活动图类似，但是<strong>它的节点都是交互图。</strong></li><li>【目的】提供了控制流的概述。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024211257.png" alt="image-20201024211256976"></p><p><u>    图中表示一个调度系统的交互概览图，跟活动图很像。其中sd的框代表具体的交互流程，ref框代表使用交互。</u></p><h3 id="7-时序图"><a href="#7-时序图" class="headerlink" title="7. 时序图"></a>7. 时序图</h3><blockquote><ul><li>【概念】时序图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。</li><li>【目的】用来表示元素状态或者值随时间的变化而变化的视图。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024211514.png" alt="image-20201024211514237"></p><p><u>图中展示了老年痴呆病人随着时间的变化病情的变化。</u></p><h3 id="8-状态图"><a href="#8-状态图" class="headerlink" title="8. 状态图"></a>8. 状态图</h3><blockquote><ul><li>【概念】状态图对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。</li><li>【目的】用来表示指定对象，在整个生命周期，响应不同事件的不同状态。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024211610.png" alt="image-20201024211610023"></p><p><u>图中描述了，门在其生命周期内所经历的状态。</u></p><h3 id="9-活动图"><a href="#9-活动图" class="headerlink" title="9. 活动图"></a>9. 活动图</h3><blockquote><ul><li>【概念】描述了具体业务用例的实现流程。</li><li>【目的】用来表示用例实现的工作流程。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024211902.png" alt="image-20201024211902500"></p><p><u>图中简单描述了，从开始到登录到查看订单列表，或者登录失败直接结束。</u></p><h3 id="10-结构图-组件图"><a href="#10-结构图-组件图" class="headerlink" title="10. 结构图 / 组件图"></a>10. 结构图 / 组件图</h3><blockquote><ul><li>【概念】描绘了系统中组件提供的、需要的接口、端口等，以及它们之间的关系。</li><li>【目的】用来展示各个组件之间的依赖关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212110.png" alt="image-20201024212110463"></p><p><u>订单系统组件依赖于客户资源库和库存系统组件。中间的虚线箭头表示依赖关系。另外两个符号，表示组件连接器，一个提供接口，一个需要接口。</u></p><h3 id="11-组合结构图"><a href="#11-组合结构图" class="headerlink" title="11. 组合结构图"></a>11. 组合结构图</h3><blockquote><ul><li>【概念】描述了一个”组合结构”的内部结构，以及他们之间的关系。这个”组合结构”可以是系统的一部分，或者一个整体。</li><li>【目的】用来表示系统中逻辑上的”组合结构”。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212223.png" alt="image-20201024212223750"></p><p><u>图中描述了Car是由车轴连接着的两个前面轮子、两个后面轮子，和引擎组合的。</u></p><h3 id="12-部署图"><a href="#12-部署图" class="headerlink" title="12. 部署图"></a>12. 部署图</h3><blockquote><ul><li>【概念】描述了系统内部的软件如何分布在不同的节点上。</li><li>【目的】用来表示软件和硬件的映射关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212347.png" alt="image-20201024212347530"></p><p><u>图中简单的表示，不同机器上面部署的不同软件。</u></p><h3 id="13-包图"><a href="#13-包图" class="headerlink" title="13. 包图"></a>13. 包图</h3><blockquote><ul><li>【概念】描绘了系统在包层面上的结构设计。</li><li>【目的】用来表示包和包之间的依赖关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212502.png" alt="image-20201024212502812"></p><ul><li>《Use》关系表示使用依赖，Web Shopping依赖Payment</li><li>《Merge》关系表示合并，Web Shopping合并了Shopping Cart就拥有了Shopping Cart的功能</li><li>《Access》关系表示私有引入，比如代码中的指定包名类名</li><li>《Import》关系表示公共引入，比如Java中的import之后，就可以直接使用import包中的类了</li></ul><h3 id="14-轮廓图"><a href="#14-轮廓图" class="headerlink" title="14. 轮廓图"></a>14. 轮廓图</h3><blockquote><ul><li>【概念】轮廓图提供了一种通用的扩展机制，用于为特定域和平台定制UML模型。</li><li>【目的】用于在特定领域中构建UML模型。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212903.png" alt="image-20201024212902942"></p><p><u>图中我们定义了一个简易的EJB的概要图。Bean是从Component扩展来的。Entity Bean和Session Bean继承了Bean。EJB拥有Remote和Home接口，和JAR包。</u></p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 面向对象技术</title>
      <link href="2020/10/24/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/"/>
      <url>2020/10/24/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="7-1-面向对象基础"><a href="#7-1-面向对象基础" class="headerlink" title="7.1 面向对象基础"></a>7.1 面向对象基础</h1><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><blockquote><p>面向对象 = 对象 + 分类 + 继承 + 通过消息的通信</p></blockquote><ol><li>对象：最基本的运行时实体，包含数据和行为</li><li>消息：对象之间的通信的一种<strong>构造</strong>叫消息</li><li>类：大体相似的对象</li><li>继承</li><li>多态</li></ol><h3 id="2-对象、消息传递和方法"><a href="#2-对象、消息传递和方法" class="headerlink" title="2. 对象、消息传递和方法"></a>2. 对象、消息传递和方法</h3><blockquote><p>对象是类的实体，尽管对象的表示在形式上与一般数据类型相似，但是它们之间的本质区别，<strong>对象之间通过消息传递方式进行通信</strong></p></blockquote><h1 id="7-2-UML"><a href="#7-2-UML" class="headerlink" title="7.2 UML"></a><a href="https://sinan106.github.io/2020/10/24/UML/">7.2 UML</a></h1><h1 id="7-3-设计模式"><a href="#7-3-设计模式" class="headerlink" title="7.3 设计模式"></a><a href="https://sinan106.github.io/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">7.3 设计模式</a></h1>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT的四种使用方式</title>
      <link href="2020/10/19/JWT%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>2020/10/19/JWT%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><ol><li>access_token 过期设置为15分钟</li><li>前端发起请求，后端验证access_token是否过期；如果过期，前端发起refresh_token请求，后端设置已再次授权标记为true，请求成功</li><li>前端发起请求，后端验证再次授权标记，如果已经再次授权，则拒绝refresh_token的请求，请求成功</li><li>如果前端每隔72小时，必须重新登录，后端检查用户最后一次登录日期，如超过72小时，则拒绝刷新token的请求，请求失败</li></ol><h1 id="1-0实现"><a href="#1-0实现" class="headerlink" title="1.0实现"></a>1.0实现</h1><ol><li><p>登录成功，返回access_token和refresh_token，客户端缓存此两种token;</p></li><li><p>使用access_token请求接口资源，成功则调用成功；如果token超时，客户端携带refresh_token调用中间件接口获取新的access_token;</p></li><li><p>中间件接受refresh_token的请求后，检查refresh_token是否过期。<br>如过期，拒绝刷新，客户端收到该状态后，跳转到登录页；<br>如未过期，生成新的access_token和refresh_token并返回给客户端（如有可能，让旧的refresh_token失效），客户端携带新的access_token重新调用上面的资源接口。</p></li><li><p>客户端退出登录或修改密码后，调用中间件注销旧的token(使access_token和refresh_token失效)，同时清空客户端的access_token和refresh_toke。</p><p> 后端表<br> id user_id client_id client_secret refresh_token expire_in create_date del_flag</p></li></ol><h1 id="2-0实现"><a href="#2-0实现" class="headerlink" title="2.0实现"></a>2.0实现</h1><p>场景： access_token访问资源 refresh_token授权访问 设置固定时间X必须重新登录</p><ol><li>登录成功，后台jwt生成access_token（jwt有效期30分钟）和refresh_token（jwt有效期15天），并缓存到redis（hash-key为token,sub-key为手机号,value为设备唯一编号（根据手机号码，可以人工废除全部token，也可以根据sub-key,废除部分设备的token。），设置过期时间为1个月(redis)，保证最终所有token都能删除)，返回后，客户端缓存此两种token;</li><li>使用access_token请求接口资源，校验成功且redis中存在该access_token（未废除）则调用成功；如果token超时，中间件删除access_token（废除）；客户端再次携带refresh_token调用中间件接口获取新的access_token;</li><li>中间件接受刷新token的请求后，检查refresh_token是否过期。<br> 如过期，拒绝刷新，删除refresh_token（废除）； 客户端收到该状态后，跳转到登录页；<br> 如未过期，检查缓存中是否有refresh_token（是否被废除），如果有，则生成新的access_token并返回给客户端，客户端接着携带新的access_token重新调用上面的资源接口。</li><li>客户端退出登录或修改密码后，调用中间件注销旧的token(中间件删除access_token、refresh_token（废除）)，同时清空客户端侧的access_token和refresh_toke。</li><li>如手机丢失，可以根据手机号人工废除指定用户设备关联的token。</li><li>以上3刷新access_token可以增加根据登录时间判断最长X时间必须重新登录，此时则拒绝刷新token。（拒绝的场景：失效，长时间未登录，频繁刷新）</li></ol><h3 id="2-0-变动"><a href="#2-0-变动" class="headerlink" title="2.0 变动"></a>2.0 变动</h3><p>1.登录<br>2.登录拦截器<br>3.增加刷新access_token接口<br>4.退出登录<br>5.修改密码</p><h1 id="3-0实现"><a href="#3-0实现" class="headerlink" title="3.0实现"></a>3.0实现</h1><p>场景：自动续期 长时间未使用需重新登录</p><ol><li>登录成功，后台jwt生成access_token（jwt有效期30分钟），并缓存到redis（hash-key为access_token,sub-key为手机号,value为设备唯一编号（根据手机号码，可以人工废除全部token），设置access_token过期时间为7天，保证最终所有token都能删除)，返回后，客户端缓存此token;</li><li>使用access_token请求接口资源，校验成功且redis中存在该access_token（未废除）则调用成功；如果token超时，中间件删除access_token（废除）,同时生成新的access_token并返回。客户端收到新的access_token，<br>再次请求接口资源。</li><li>客户端退出登录或修改密码后，调用中间件注销旧的token(中间件删除access_token（废除）)，同时清空客户端侧的access_token。</li><li>以上2 可以增加根据登录时间判断最长X时间必须重新登录，此时则拒绝刷新token。（拒绝的场景：长时间未登录，频繁刷新）</li><li>如手机丢失，可以根据手机号人工废除指定用户设备关联的token。</li></ol><h3 id="3-0-变动"><a href="#3-0-变动" class="headerlink" title="3.0 变动"></a>3.0 变动</h3><p>1.登录<br>2.登录拦截器<br>3.退出登录<br>4.修改密码</p><h1 id="4-0实现"><a href="#4-0实现" class="headerlink" title="4.0实现"></a>4.0实现</h1><p>场景：token过期重新登录 长时间未使用需重新登录</p><p>1.登录成功，后台jwt生成access_token（jwt有效期7天），并缓存到redis，key为”user_id:access_token” + 用户id,value为access_token（根据用户id，可以人工废除指定用户全部<br>token），设置缓存过期时间为7天，保证最终所有token都能删除，请求返回后，客户端缓存此access_token；<br>2.使用access_token请求接口资源，校验成功且redis中存在该access_token（未废除）则调用成功；如果token超时，中间件删除access_token（废除）,同时生成新的access_token并返回。客户端收到新的access_token，再次请求接口资源。<br>3.客户端退出登录或修改密码后，调用中间件注销旧的token(中间件删除access_token（废除）)，同时清空客户端侧的access_token。<br>4.以上2 可以增加根据登录时间判断最长X时间必须重新登录，此时则拒绝刷新token。（拒绝的场景：长时间未登录，频繁刷新）<br>5.如手机丢失，可以根据手机号人工废除指定用户设备关联的token。</p><h3 id="4-0-变动"><a href="#4-0-变动" class="headerlink" title="4.0 变动"></a>4.0 变动</h3><p>1.登录<br>2.登录拦截器<br>3.退出登录<br>4.修改密码</p><h1 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h1><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><ol><li>在登录接口中 如果校验账号密码成功 则根据用户id和用户类型创建jwt token(有效期设置为-1，即永不过期),得到A</li><li>更新登录日期(当前时间new Date()即可)（业务上可选），得到B</li><li>在redis中缓存key为ACCESS_TOKEN:userId:A(加上A是为了防止用户多个客户端登录 造成token覆盖),value为B的毫秒数（转换成字符串类型），过期时间为7天（7 * 24 * 60 * 60）</li><li>在登录结果中返回json格式为{“result”:”success”,”token”: A}</li><li>用户在接口请求header中携带token进行登录，后端在所有接口前置拦截器进行拦截，作用是解析token 拿到userId和用户类型（用户调用业务接口只需要传token即可）， 如果解析失败（抛出SignatureException），则返回json（code = 0 ,info= Token验证不通过, errorCode = ‘1001’）； 此外如果解析成功，验证redis中key为ACCESS_TOKEN:userId:A 是否存在 如果不存在 则返回json（code = 0 ,info= 会话过期请重新登录, errorCode = ‘1002’）； 如果缓存key存在，则自动续7天超时时间（value不变），实现频繁登录用户免登陆。</li><li>把userId和用户类型放入request参数中 接口方法中可以直接拿到登录用户信息</li><li>如果是修改密码或退出登录 则废除access_tokens（删除key）</li></ol><h1 id="前端（VUE）"><a href="#前端（VUE）" class="headerlink" title="前端（VUE）"></a>前端（VUE）</h1><ol><li>用户登录成功，则把username存入cookie中，key为loginUser;把token存入cookie中，key为accessToken 把token存入Vuex全局状态中</li><li>进入首页</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea创建 maven tomcat项目</title>
      <link href="2020/10/19/idea%E5%88%9B%E5%BB%BA-maven-tomcat%E9%A1%B9%E7%9B%AE/"/>
      <url>2020/10/19/idea%E5%88%9B%E5%BB%BA-maven-tomcat%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-新建maven项目-选择webapp"><a href="#1-新建maven项目-选择webapp" class="headerlink" title="1. 新建maven项目 选择webapp"></a>1. 新建maven项目 选择webapp</h1><p><img src="https://img-blog.csdnimg.cn/20200715162502382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjExODkz,size_16,color_FFFFFF,t_70" alt="新建"></p><h1 id="2-导包后Edit-Configurations-选择tomcat-和-jdk-如有报错-fix-即可-war包部署选择-war-exploded，URL是选择每次运行时默认打开的链接，可以和后续的Application-Context配置一样"><a href="#2-导包后Edit-Configurations-选择tomcat-和-jdk-如有报错-fix-即可-war包部署选择-war-exploded，URL是选择每次运行时默认打开的链接，可以和后续的Application-Context配置一样" class="headerlink" title="2. 导包后Edit Configurations,选择tomcat 和 jdk 如有报错 fix 即可,war包部署选择 war:exploded，URL是选择每次运行时默认打开的链接，可以和后续的Application Context配置一样"></a>2. 导包后Edit Configurations,选择tomcat 和 jdk 如有报错 fix 即可,war包部署选择 war:exploded，URL是选择每次运行时默认打开的链接，可以和后续的Application Context配置一样</h1><p><img src="https://img-blog.csdnimg.cn/202007151626513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjExODkz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="3-接着打开Deployment，里面就已经有个war包了，-然后修改-Application-Context-这就是你url的访问路径"><a href="#3-接着打开Deployment，里面就已经有个war包了，-然后修改-Application-Context-这就是你url的访问路径" class="headerlink" title="3. 接着打开Deployment，里面就已经有个war包了，==然后修改 Application Context== 这就是你url的访问路径"></a>3. 接着打开Deployment，里面就已经有个war包了，==然后修改 Application Context== 这就是你url的访问路径</h1><p><img src="https://img-blog.csdnimg.cn/20200715163050658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjExODkz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="4-运行即可，会显示index-jsp的内容"><a href="#4-运行即可，会显示index-jsp的内容" class="headerlink" title="4.运行即可，会显示index.jsp的内容"></a>4.运行即可，会显示index.jsp的内容</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="2020/10/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2020/10/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Lambda 一个重要用法是简化某些<em>匿名内部类</em>，或者说是对<em>函数式接口</em>的实现。</p><blockquote><p>函数式接口(Functional Interface)是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。(@Functional interface修饰)</p></blockquote><p>简单例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; &#123;<span class="keyword">return</span> <span class="number">5</span>&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">(x) -&gt; &#123;<span class="keyword">return</span> <span class="number">2</span> * x&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;<span class="keyword">return</span> x – y&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; &#123;System.out.print(s)&#125;</span><br></pre></td></tr></table></figure><p>省略写法：</p><ol><li>省略参数类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; &#123;<span class="keyword">return</span> x – y&#125; </span><br></pre></td></tr></table></figure></li><li>单个参数省略小括号(无参时要写小括号)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; &#123;<span class="keyword">return</span> <span class="number">2</span> * x&#125;  </span><br></pre></td></tr></table></figure></li><li>无返回且仅有一条语句，省略大括号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure></li><li>有返回且仅有一条语句，省略return 和 大括号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br></pre></td></tr></table></figure><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1></li><li>静态方法调用（通过类调用）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReMultiple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; <span class="comment">//唯一的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">syntax3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接用类名加方法名调用</span></span><br><span class="line">ReMultiple lam3 = syntax3::fun1;</span><br><span class="line">System.out.println(lam3.show(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// out: 7</span></span><br></pre></td></tr></table></figure></li><li>Java8 常用内置函数式接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.Predicate 参数T 返回值boolean 用于判定</span></span><br><span class="line"><span class="comment">// 若为偶数则返回真</span></span><br><span class="line">Predicate&lt;Integer&gt; predicate = t -&gt; t%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line"><span class="comment">// removeIf(Predicate)(将list中的每个对象都通过Predicate，若为真则删除)</span></span><br><span class="line">list.removeIf(predicate);</span><br><span class="line">list.forEach(System.out::print); <span class="comment">// out: 135 因为246为偶数 返回真 被删除了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Consumer 参数T 无返回 用于消费某值</span></span><br><span class="line">Consumer&lt;Integer&gt; consumer = System.out::print;</span><br><span class="line">   list.forEach(consumer); <span class="comment">//123456</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//3. Function 参数T 输出R 用于类型转换</span></span><br><span class="line">String str = <span class="string">&quot;aaaaaa&quot;</span>;</span><br><span class="line">   Function&lt;String, Integer&gt; function = String::length;</span><br><span class="line">   System.out.println(function.apply(str)); <span class="comment">//out: 6</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 结构化开发</title>
      <link href="2020/10/19/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>2020/10/19/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1-结构化开发"><a href="#6-1-结构化开发" class="headerlink" title="6. 1 结构化开发"></a>6. 1 结构化开发</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote><ol><li>指导思想是自顶向下、逐层分解</li><li>基本原则是功能的分解与抽象</li><li>适合于数据处理领域的问题，但是不适合解决大规模、特别复杂的项目，难以适应需求的变化</li></ol></blockquote><h3 id="2-系统设计的基本原理"><a href="#2-系统设计的基本原理" class="headerlink" title="2.系统设计的基本原理"></a>2.系统设计的基本原理</h3><h5 id="1-抽象"><a href="#1-抽象" class="headerlink" title="1. 抽象"></a>1. 抽象</h5><h5 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2. 模块化"></a>2. 模块化</h5><h5 id="3-信息屏蔽"><a href="#3-信息屏蔽" class="headerlink" title="3. 信息屏蔽"></a>3. 信息屏蔽</h5><h5 id="4-模块独立-衡量模块独立程度的标准：耦合性和内聚性"><a href="#4-模块独立-衡量模块独立程度的标准：耦合性和内聚性" class="headerlink" title="4. 模块独立 : 衡量模块独立程度的标准：耦合性和内聚性"></a>4. 模块独立 : 衡量模块独立程度的标准：耦合性和内聚性</h5><ol><li><p>耦合</p><blockquote><p>模块间相对独立性的度量</p></blockquote><ol><li>无直接耦合：没有任何关系</li><li>数据耦合：两模块间传递简单的数据值 / 值传递</li><li>标记耦合：传递数据结构</li><li>控制耦合：一个模块调用另一个时传递变量，被调模块通过变量值不同来决定执行那个功能。被调模块通常有多个功能</li><li>外部耦合：通过软件之外的环境联结，<strong>如通过IO设备耦合到特定设备、格式、通信协议</strong></li><li>公共耦合：通过一个公共数据环境相互作用，<strong>如全局的变量或数据结构</strong></li><li>内容耦合：一个模块直接使用另一个模块的内部数据，或通过非正常入口进入另一个模块</li></ol></li><li><p>内聚</p><blockquote><p>一个模块内部各个元素结合的繁密程度</p></blockquote><ol><li>偶然/巧合内聚：一个模块内各元素都没有任何联系</li><li>逻辑内聚：模块内执行若干逻辑上相似的功能，通过参数确定该模块完成哪一个功能</li><li>时间内聚：同时执行的动作组合在一起，<strong>如系统初始化</strong></li><li>过程内聚：一个模块完成多个任务，这些任务必须按照指定的顺序进行</li><li>通信内聚：模块内的所有处理元素都在一个数据结构上操作，或者处理使用相同的输入数据或者产生相同的输出数据，<strong>如向某个数据结构读/写数据</strong></li><li>顺序内聚：模块中的任务必须顺序执行，且前一个的输出就是下一个的输入</li><li>功能内聚：模块内的所有元素共同完成一个功能，缺一不可</li></ol><p> <strong>Tip：顺序内聚强调数据间的传递，然而过程内聚不强调</strong></p></li></ol><h3 id="3-扇入系数与扇出系数"><a href="#3-扇入系数与扇出系数" class="headerlink" title="3. 扇入系数与扇出系数"></a>3. 扇入系数与扇出系数</h3><blockquote><p>一个模块直接调用其他模块的个数称为模块的扇出系数，反之，被调用的次数被称为扇入系数。</p><p>一般扇入和扇出系数为3，4，不会超过7</p></blockquote><h1 id="6-2-数据流图"><a href="#6-2-数据流图" class="headerlink" title="6.2 数据流图"></a>6.2 数据流图</h1><blockquote><p>数据流图也称为数据流程图(Data Flow Diagram DFD)</p></blockquote><h4 id="基本元素："><a href="#基本元素：" class="headerlink" title="基本元素："></a>基本元素：</h4><ul><li>数据流<img src="http://cdn.zhouxug.cn/20201019194428.png" alt="image-20201019194428595" style="zoom:50%;" /></li></ul><ul><li>加工<img src="http://cdn.zhouxug.cn/20201019194349.png" alt="image-20201019194349384" style="zoom:50%;" /></li></ul><ul><li>数据存储<img src="http://cdn.zhouxug.cn/20201019194404.png" alt="image-20201019194404865" style="zoom:50%;" /></li></ul><ul><li>外部实体<img src="http://cdn.zhouxug.cn/20201019194327.png" alt="image-20201019194327089" style="zoom:50%;" /></li></ul><h1 id="6-3-集成测试策略"><a href="#6-3-集成测试策略" class="headerlink" title="6.3 集成测试策略"></a>6.3 集成测试策略</h1><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ol><li>驱动模块：根据测试用例的设计去调用被测试模块</li><li>桩模块：用于模拟某下级模块“代替/假”模块，并可以模拟各种返回值</li></ol><p>简单的说，被测模块上层为驱动模块，是调用被测模块的，被测模块下层为桩模块，是被被测模块调用的。</p><h3 id="2-各类测试分类"><a href="#2-各类测试分类" class="headerlink" title="2. 各类测试分类"></a>2. 各类测试分类</h3><h4 id="1-自顶向下"><a href="#1-自顶向下" class="headerlink" title="1. 自顶向下"></a>1. 自顶向下</h4><blockquote><p> ​    采用了和设计一样的顺序对系统进行测试，它在第一时间内对系统的控制接口进行验证；采用自顶向下的集成测试首先集中于顶层的组件，然后逐步测试处于底层的组件；可采用深度优先和广度优先策略。</p></blockquote><ul><li><p>优点：</p><ul><li>在测试过程中较早的验证了主要的控制和判断点</li><li>在过程的早期阶段测试，有助于最大限度地减少对驱动程序的需求</li></ul></li><li><p>缺点：</p><ul><li>桩的开发和维护时本策略的最大成本</li><li>底层组件行为的验证被推迟了</li><li>不能很好地支持有限功能的早期发布</li></ul></li></ul><h4 id="2-自顶向上"><a href="#2-自顶向上" class="headerlink" title="2. 自顶向上"></a>2. 自顶向上</h4><blockquote><p>​    由下而上的方法要求首先测试和集成最低级别的单元。这些单元常被称为实用工具模块。</p></blockquote><ul><li>优点：<ul><li>实用工具模块在开发过程的早期阶段测试，最大限度地减少了对桩的需求</li><li>最初的工作可以并行</li><li>支持故障隔离</li></ul></li><li>缺点：<ul><li>驱动的开发工作量大</li><li>高层的验证被推迟</li><li>设计上的错误不容易发现</li></ul></li></ul><h4 id="3-三明治"><a href="#3-三明治" class="headerlink" title="3. 三明治"></a>3. 三明治</h4><blockquote><p>​    把系统划分成三层，中间一层为目标层；测试的时候，对目标层上面的一层使用由顶向下的集成策略，对目标层下面的一层使用自底向上的集成策略，最后测试在目标层会合。</p></blockquote><ul><li>优点：<ul><li>可以较早的验证主要的控制和判断点和底层模块（集合了自顶向下和自底向上的优点）</li></ul></li><li>缺点：<ul><li>中间层的在被集成前测试不充分</li></ul></li></ul><h4 id="4-一次性-大爆炸"><a href="#4-一次性-大爆炸" class="headerlink" title="4. 一次性/大爆炸"></a>4. 一次性/大爆炸</h4><blockquote><p>首先对每个模块分别进行单元测试，然后再把所有单元组装在一起进行测试，最终得到要求的软件系统</p></blockquote><ul><li><p>缺点：</p><ul><li>由于程序中不可避免地存在模块间接口、全局数据结构等方面的问题，所以一次试运行成功的可能性并不很大</li><li>在发现错误的时候，其问题定位和修改都比较困难；</li><li>即使被测系统能够被一次性集成，但还是会有许多接口错误很容易的躲过测试而进入到系统测试范围内。</li></ul></li><li><p>适用范围</p><ul><li>维护型或增强型项目，之前的项目已经足够稳定</li><li>系统较小</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 结构化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-plus_hello</title>
      <link href="2020/10/18/Mybatis-plus_hello/"/>
      <url>2020/10/18/Mybatis-plus_hello/</url>
      
        <content type="html"><![CDATA[<h1 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h1><h4 id="config-MyBatisPlus-Config"><a href="#config-MyBatisPlus-Config" class="headerlink" title="config.MyBatisPlus-Config"></a>config.MyBatisPlus-Config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 标记为配置文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.zhouxug.hello.dao&quot;)</span>  <span class="comment">// 扫描DAO层文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  分页插件 分页具体使用会在后续讲述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dao-BlogMapper-被扫描文件"><a href="#dao-BlogMapper-被扫描文件" class="headerlink" title="dao.BlogMapper 被扫描文件"></a>dao.BlogMapper 被扫描文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> <span class="comment">// 作为仓库 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Blog</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//继承自 BaseMapper&lt;T&gt; 泛型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-自动填充"><a href="#2-自动填充" class="headerlink" title="2. 自动填充"></a>2. 自动填充</h1><h4 id="config-MyMetaObjectHandler"><a href="#config-MyMetaObjectHandler" class="headerlink" title="config.MyMetaObjectHandler"></a>config.MyMetaObjectHandler</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需实现 MetaObjectHandler 中 insertFill 和 updateFill 方法</span></span><br><span class="line"><span class="comment"> * 使用时就要取消掉数据库的自动填充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入时填充</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// setFieldValByName </span></span><br><span class="line">        <span class="comment">// 第一个参数是你要填充字段的  实体名称  ！！！</span></span><br><span class="line">        <span class="comment">// 第二个为填充值</span></span><br><span class="line">        <span class="comment">// 第三个为元数据</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;blogPostTime&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;blogUpdateTime&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时填充</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;blogUpdateTime&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-分页插件"><a href="#3-分页插件" class="headerlink" title="3. 分页插件"></a>3. 分页插件</h1><h4 id="config-MyBatisPlus-Config-1"><a href="#config-MyBatisPlus-Config-1" class="headerlink" title="config.MyBatisPlus-Config"></a>config.MyBatisPlus-Config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在config中配置分页插件 </span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 使用Page来指定分页</span></span><br><span class="line"><span class="comment">// current 为当前第几页 从一开始</span></span><br><span class="line"><span class="comment">// size 为每一页的行数</span></span><br><span class="line">Page&lt;Attachment&gt; page = <span class="keyword">new</span> Page&lt;&gt;(current, size);</span><br><span class="line">   QueryWrapper&lt;Attachment&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">   wrapper.orderByDesc(<span class="string">&quot;upload_time&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用mapper 中的selectPage 来传入wrapper 和 page 参数 从而达到分页</span></span><br><span class="line">   IPage&lt;Attachment&gt; attachmentIPage = attachmentMapper.selectPage(page, wrapper);</span><br><span class="line">   List&lt;Attachment&gt; records = attachmentIPage.getRecords();</span><br></pre></td></tr></table></figure><h1 id="4-自定义SQL"><a href="#4-自定义SQL" class="headerlink" title="4. 自定义SQL"></a>4. 自定义SQL</h1><h4 id="1-注解方式"><a href="#1-注解方式" class="headerlink" title="1. 注解方式"></a>1. 注解方式</h4><h4 id="dao-UserMapper-声明并定义方法"><a href="#dao-UserMapper-声明并定义方法" class="headerlink" title="dao.UserMapper 声明并定义方法"></a>dao.UserMapper 声明并定义方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Mapper文件中直接定义方法</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set user_name = #&#123;user_name&#125;, description = #&#123;description&#125;, icon = #&#123;icon&#125; where email = #&#123;email&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUserInfo</span><span class="params">(<span class="meta">@Param(&quot;user_name&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;description&quot;)</span> String description,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;icon&quot;)</span> String icon,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;email&quot;)</span> String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最后通过service-Impl-通过mapper调用"><a href="#最后通过service-Impl-通过mapper调用" class="headerlink" title="最后通过service.Impl 通过mapper调用"></a>最后通过service.Impl 通过mapper调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.updateUserInfo();</span><br></pre></td></tr></table></figure><h4 id="2-XML方式"><a href="#2-XML方式" class="headerlink" title="2. XML方式"></a>2. XML方式</h4><h4 id="application-yml-指定mapper-xml位置"><a href="#application-yml-指定mapper-xml位置" class="headerlink" title="application.yml 指定mapper.xml位置"></a>application.yml 指定mapper.xml位置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="comment"># 如果是放在src/main/java目录下 classpath:/com/\*/*/mapper/\*Mapper.xml*</span></span><br><span class="line"><span class="comment"># 如果是放在resource目录 classpath:/mapper/**.xml*</span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**.xml</span></span><br></pre></td></tr></table></figure><h4 id="dao-UserMapper-声明方法"><a href="#dao-UserMapper-声明方法" class="headerlink" title="dao.UserMapper 声明方法"></a>dao.UserMapper 声明方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Mapper文件中直接定义方法</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectByName</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UserMapper-xml-定义SQL"><a href="#UserMapper-xml-定义SQL" class="headerlink" title="UserMapper.xml 定义SQL"></a>UserMapper.xml 定义SQL</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zhouxug.hello.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user where name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="最后通过service-Impl-通过mapper调用-1"><a href="#最后通过service-Impl-通过mapper调用-1" class="headerlink" title="最后通过service.Impl 通过mapper调用"></a>最后通过service.Impl 通过mapper调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.updateUserInfo();</span><br></pre></td></tr></table></figure><h1 id="5-时间查询"><a href="#5-时间查询" class="headerlink" title="5. 时间查询"></a>5. 时间查询</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply 拼接sql 语句</span></span><br><span class="line"><span class="comment">// 使用date_format(数据库字段名， &#x27;%Y&#x27;/&#x27;%m&#x27;/&#x27;%d&#x27;)</span></span><br><span class="line">wrapper.apply(<span class="string">&quot;date_format(post_time, &#x27;%Y&#x27;) = &#123;0&#125;&quot;</span>, <span class="string">&quot;2020&quot;</span>);</span><br><span class="line">List&lt;Blog&gt; blogList = blogMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure><h1 id="6-遇到的一些坑"><a href="#6-遇到的一些坑" class="headerlink" title="6. 遇到的一些坑"></a>6. 遇到的一些坑</h1><h4 id="1-Update-User表中的userName时，sql拼接会缺失userName"><a href="#1-Update-User表中的userName时，sql拼接会缺失userName" class="headerlink" title="1. Update User表中的userName时，sql拼接会缺失userName"></a>1. Update User表中的userName时，sql拼接会缺失userName</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要代码</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">&quot;new&quot;</span>);</span><br><span class="line">wrapper.eq(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;@example.com&quot;</span>);</span><br><span class="line">userMapper.update(user, wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql :  update user ser where email = &#123; &#125; </span></span><br><span class="line"><span class="comment">// 应当为 ： update user ser user_name = “new” where email = &#123; &#125;</span></span><br></pre></td></tr></table></figure><h5 id="解决方式：使用自定义sql-updateUserInfo"><a href="#解决方式：使用自定义sql-updateUserInfo" class="headerlink" title="解决方式：使用自定义sql : updateUserInfo"></a>解决方式：使用自定义sql : updateUserInfo</h5><h4 id="dao-UserMapper"><a href="#dao-UserMapper" class="headerlink" title="dao.UserMapper"></a>dao.UserMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set user_name = #&#123;user_name&#125;, description = #&#123;description&#125;, icon = #&#123;icon&#125; where email = #&#123;email&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUserInfo</span><span class="params">(<span class="meta">@Param(&quot;user_name&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;description&quot;)</span> String description,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;icon&quot;)</span> String icon,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;email&quot;)</span> String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最后通过service-Impl-通过mapper调用-2"><a href="#最后通过service-Impl-通过mapper调用-2" class="headerlink" title="最后通过service.Impl 通过mapper调用"></a>最后通过service.Impl 通过mapper调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.updateUserInfo();</span><br></pre></td></tr></table></figure><h4 id="2-wrapper-select-获取部分字段时实体类与数据库映射失败"><a href="#2-wrapper-select-获取部分字段时实体类与数据库映射失败" class="headerlink" title="2. wrapper.select 获取部分字段时实体类与数据库映射失败"></a>2. wrapper.select 获取部分字段时实体类与数据库映射失败</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果实体类与数据库字段是驼峰式对应，则没有问题</span></span><br><span class="line"><span class="comment">// 但是如果是别名，哪怕设置了 @TableField(value = &quot;&quot;) 仍会无法映射</span></span><br><span class="line"> wrapper.select(<span class="string">&quot;post_time&quot;</span>);</span><br><span class="line"><span class="comment">// sql : SELECT post_time FROM blog</span></span><br><span class="line"><span class="comment">// 应当为 : SELECT post_time AS blogPostTime FROM blog</span></span><br><span class="line"><span class="comment">// 这里post_time别名为 blogPostTime 并且设置了@TableField(value = &quot;blogPostTime&quot;) 但是仍有问题</span></span><br></pre></td></tr></table></figure><h5 id="解决方法1：使用select-Class-entityClass-Predicate-predicate"><a href="#解决方法1：使用select-Class-entityClass-Predicate-predicate" class="headerlink" title="解决方法1：使用select(Class entityClass, Predicate predicate)"></a>解决方法1：使用select(Class<T> entityClass, Predicate<TableFieldInfo> predicate)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为查询的实体类</span></span><br><span class="line"><span class="comment">// 第二个参数为lambda表达式 </span></span><br><span class="line"><span class="comment">// getColumn().equals() 是数据库中的字段名</span></span><br><span class="line"><span class="comment">// getProperty().equals() 是实体类中的字段名</span></span><br><span class="line"><span class="comment">// 连接多个字段使用 &amp;&amp; 连接</span></span><br><span class="line"><span class="comment">// !表示排除这个字段 反之为需要这个字段</span></span><br><span class="line">wrapper.select(Blog.class, i -&gt; !i.getColumn().equals(<span class="string">&quot;update_time&quot;</span>)</span><br><span class="line">        &amp;&amp; !i.getProperty().equals(<span class="string">&quot;blogContent&quot;</span>));</span><br><span class="line"></span><br><span class="line">wrapper.select(Blog.class, i -&gt; i.getColumn().equals(<span class="string">&quot;post_time&quot;</span>))；</span><br></pre></td></tr></table></figure><h5 id="解决方法2：使用select-String-column-手动拼接字段"><a href="#解决方法2：使用select-String-column-手动拼接字段" class="headerlink" title="解决方法2：使用select(String column)手动拼接字段"></a>解决方法2：使用select(String column)手动拼接字段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrapper.select(<span class="string">&quot;post_time AS blogPostTime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql : SELECT post_time AS blogPostTime FROM blog </span></span><br><span class="line"><span class="comment">// 感觉 select(column)是直接拼接进去的</span></span><br></pre></td></tr></table></figure><h5 id="题外话：distinct的使用"><a href="#题外话：distinct的使用" class="headerlink" title="题外话：distinct的使用"></a>题外话：distinct的使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接加在 数据库字段名前即可 </span></span><br><span class="line"><span class="comment">// 但是目前不知道 select(Class, Predicate) 如何使用</span></span><br><span class="line">select(<span class="string">&quot;distinct post_time AS blogPostTime&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-主键自增问题"><a href="#3-主键自增问题" class="headerlink" title="3. 主键自增问题"></a>3. 主键自增问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的type = IdType.AUTO自增是指依靠数据库自增，而不是mp来填充</span></span><br><span class="line">    <span class="comment">// 所以数据库id一定要填自增</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer tagId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String tagName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 软件工程基础</title>
      <link href="2020/10/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>2020/10/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-软件工程概述"><a href="#5-1-软件工程概述" class="headerlink" title="5.1 软件工程概述"></a>5.1 软件工程概述</h1><h3 id="能力成熟度模型-CMM"><a href="#能力成熟度模型-CMM" class="headerlink" title="能力成熟度模型 CMM"></a>能力成熟度模型 CMM</h3><blockquote><p>对软件过后曾组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进，软件组织的能力经过这些阶段逐步提高。</p></blockquote><p>CMM将软件过程改进分为以下5个成熟度级别</p><ol><li><p>初始级</p></li><li><p>可重复级</p></li><li><p>已定义级</p></li><li><p>已管理级</p></li><li><p>优化级</p></li></ol><h1 id="5-2-软件过程模型"><a href="#5-2-软件过程模型" class="headerlink" title="5.2 软件过程模型"></a>5.2 软件过程模型</h1><h3 id="1-瀑布模型"><a href="#1-瀑布模型" class="headerlink" title="1. 瀑布模型"></a>1. 瀑布模型</h3><blockquote><p>​    将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落</p></blockquote><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li>容易理解，管理成本低</li><li>强调开发的阶段性早期计划及需求调查和产品测试</li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>要求客户必须完整、正确和清晰的表达他们的需要</li><li>在开始的两三个阶段中很难评估真正的进度状态，在快结束时会有大量的集成测试工作，直到整个项目完成之前都不能演示系统的能力</li><li>需求或设计中的错误往往只有到了后期才能发现，<strong>对于项目风险的控制能力较弱</strong>。</li></ol><h3 id="2-增量模型​"><a href="#2-增量模型​" class="headerlink" title="2. 增量模型​"></a>2. 增量模型​</h3><blockquote><p>​    假设将需求分段为一系列增量产品，每一增量可以分别开发。该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”</p></blockquote><img src="http://cdn.zhouxug.cn/20201018104619.png" alt="增量模型" style="zoom:125%;" /><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ol><li>瀑布模型所有优点</li><li>第一个可交付版本所需的成本和时间很少</li><li>开发由增量表示的小系统所承担的风险较小</li></ol><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>若没有对用户的变更要求进行规划，那么产生的初始增量有可能导致之后的增量不稳定</li><li>若需求不像早期思考的那样稳定和完整，一些增量就可能要重新开发，重新发布</li><li>管理成本、进度和配置的复杂性较高</li></ol><h3 id="3-原型模型"><a href="#3-原型模型" class="headerlink" title="3. 原型模型"></a>3. 原型模型</h3><blockquote><p>​    原型是预期系统的一个可执行版本，反应了系统性质的一个子集。一个原型不必满足所有约束，其目的是快速、低成本的构建原型。然后交付给客户使用，并收集反馈意见，这些意见将在下一轮中对原型进行改进。</p></blockquote><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>​    适合在开发初期用户需求不清晰或经常变化的情况。当系统不太复杂时，采用该方法比较好</p><h4 id="增量模型与原型模型的区别"><a href="#增量模型与原型模型的区别" class="headerlink" title="增量模型与原型模型的区别"></a>增量模型与原型模型的区别</h4><ol><li>增量的迭代可以并行，而原型不行</li><li>增量是一般具有底层框架和平台的项目，而原型则是开发需求不明确、架构风险打的项目。</li></ol><h3 id="4-螺旋模型"><a href="#4-螺旋模型" class="headerlink" title="4. 螺旋模型"></a>4. 螺旋模型</h3><blockquote><p>​    对于复杂的大型软件，开发一个原型通常达不到要求。螺旋模型将瀑布模型和演化结合起来，加入了风险分析。</p></blockquote><p>螺旋模型将开发过程分为几个螺旋周期，每个周期大致和瀑布模型相符。四步流程如下</p><ol><li>制定计划</li><li>风险分析</li><li>实施工程</li><li>用户评估</li></ol><p><img src="http://cdn.zhouxug.cn/20201018104623.png" alt="螺旋模型"></p><p><strong>螺旋模型强调风险分析，<u>因此特别适合庞大、复杂且具有高风险的系统</u></strong>    ctrl + u 下划线</p><h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><ol><li>支持用户需求的动态变化，有助于提高软件的适应能力</li><li>为项目管理人员及时调整管理决策提供了便利，从而降低了风险</li></ol><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>要求开发人员有相当丰富的风险评估能力和专业知识</li><li>过多的迭代次数会增加开发成本，延迟提交时间</li></ol><h3 id="5-喷泉模型"><a href="#5-喷泉模型" class="headerlink" title="5. 喷泉模型"></a>5. 喷泉模型</h3><blockquote><p>以用户需求为动力，以对象作为驱动的模型，<strong>适合面向对象的开发</strong></p></blockquote><p><img src="http://cdn.zhouxug.cn/20201018104628.png" alt="image-20201014193317591"></p><h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><ol><li>克服了瀑布模型和多项开发活动集成的局限性</li><li>允许各个开发活动交叉迭代进行，不必每次 需求分析 -&gt; 设计活动 -&gt; 编码，提高开发效率节省了大量开发时间</li></ol><h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>由于开发的各个阶段是重叠的，需要大量的开发人员，不利于项目管理</li><li>要求严格的文档管理，审核难度大</li></ol><h3 id="6-统一过程模型-UP"><a href="#6-统一过程模型-UP" class="headerlink" title="6. 统一过程模型 UP"></a>6. 统一过程模型 UP</h3><blockquote><p>“用例和风险驱动，以架构为中心，迭代并且增量”的开发模型</p></blockquote><p>统一过程定义了4个技术阶段及其制品</p><ol><li>起始阶段：生命周期目标</li><li>精化阶段：生命周期架构</li><li>构建阶段：初始运作功能</li><li>移交阶段：产品发布</li></ol><h3 id="7-敏捷方法"><a href="#7-敏捷方法" class="headerlink" title="7. 敏捷方法"></a>7. 敏捷方法</h3><blockquote><p>软件开发过程中加入灵活性，能在开发周期的后期增加或改变需求</p></blockquote><h4 id="1-极限编程-XP"><a href="#1-极限编程-XP" class="headerlink" title="1. 极限编程 XP"></a>1. 极限编程 XP</h4><blockquote><p>主要解决代码质量低的问题，无法提升代码速度</p></blockquote><p>四大价值观：</p><ol><li>沟通</li><li>简单性</li><li>反馈</li><li>勇气</li></ol><h4 id="2-水晶法-Crystal"><a href="#2-水晶法-Crystal" class="headerlink" title="2. 水晶法 Crystal"></a>2. 水晶法 Crystal</h4><blockquote><p>每一个不同的项目都需要一套不同的策略、约定和方法论，认为人对软件质量有重要的影响。通过更好地交流和经常性的交付，软件生产力得到提高</p></blockquote><h4 id="3-并列争求法-Scrum"><a href="#3-并列争求法-Scrum" class="headerlink" title="3. 并列争求法 Scrum"></a>3. 并列争求法 Scrum</h4><blockquote><p>使用迭代的方法，把每30天一次的迭代称为一个“冲刺”。多个自组织和自治的小组<strong>并行</strong>地递增且<strong>竞争</strong>实现产品。</p></blockquote><h4 id="4-自适应软件开发-ASD"><a href="#4-自适应软件开发-ASD" class="headerlink" title="4. 自适应软件开发 ASD"></a>4. 自适应软件开发 ASD</h4><h1 id="5-3-测试方法"><a href="#5-3-测试方法" class="headerlink" title="5.3 测试方法"></a>5.3 测试方法</h1><h3 id="1-黑盒测试"><a href="#1-黑盒测试" class="headerlink" title="1. 黑盒测试"></a>1. 黑盒测试</h3><blockquote><p>也称为功能测试，在完全不考虑软件内部结构和特性情况下，测试软件外部特性</p></blockquote><h3 id="2-白盒测试"><a href="#2-白盒测试" class="headerlink" title="2.白盒测试"></a>2.白盒测试</h3><blockquote><p>也成为结构测试，根据程序内部机构和逻辑来设计测试用例，对程序的路径和过程进行测试</p></blockquote><h5 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1. 语句覆盖"></a>1. 语句覆盖</h5><p>只用满足一个案例，走过所有的语句即可</p><h5 id="2-判定-分支-覆盖"><a href="#2-判定-分支-覆盖" class="headerlink" title="2. 判定(分支)覆盖"></a>2. 判定(分支)覆盖</h5><p>对于判断语句，要设定T/F，相比语句覆盖，新增False</p><img src="http://cdn.zhouxug.cn/20201018104631.png" alt="image-20201017153157639" style="zoom:80%;" /><h5 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3. 条件覆盖"></a>3. 条件覆盖</h5><p>判断语句中变量每个值都要考虑一遍</p><img src="http://cdn.zhouxug.cn/20201018104634.png" alt="image-20201017153212357" style="zoom:80%;" /><h5 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定/条件覆盖"></a>4. 判定/条件覆盖</h5><p>判定覆盖各条件覆盖交叉，针对于判定中的条件取值 </p><img src="http://cdn.zhouxug.cn/20201018104636.png" alt="image-20201017153319004" style="zoom:80%;" /><h5 id="5-组合覆盖"><a href="#5-组合覆盖" class="headerlink" title="5. 组合覆盖"></a>5. 组合覆盖</h5><img src="http://cdn.zhouxug.cn/20201018104638.png" alt="image-20201017153349607" style="zoom:80%;" /><h5 id="6-路径覆盖"><a href="#6-路径覆盖" class="headerlink" title="6. 路径覆盖"></a>6. 路径覆盖</h5><img src="http://cdn.zhouxug.cn/20201018104642.png" alt="image-20201017153412730" style="zoom:80%;" /><h1 id="5-4-进度管理"><a href="#5-4-进度管理" class="headerlink" title="5.4 进度管理"></a>5.4 进度管理</h1><h3 id="1-Gantt图"><a href="#1-Gantt图" class="headerlink" title="1. Gantt图"></a>1. Gantt图</h3><blockquote><p>清晰地描述每个任务从何时开始，到何时结束，任务进度进展情况以及各个任务之间的并行性。但是不能反映各任务间的依赖关系，难以确定项目的关键</p></blockquote><p><img src="http://cdn.zhouxug.cn/20201018104644.png" alt="image-20201017153850807"></p><h3 id="2-PERT图-（类似AOE网）"><a href="#2-PERT图-（类似AOE网）" class="headerlink" title="2. PERT图 （类似AOE网）"></a>2. PERT图 （类似AOE网）</h3><blockquote><p>PERT图给出了每个任务的开始时间、结束时间该任务完成所需时间，还给出了任务间的关系，即哪些任务完成后才能开始另一项任务。<strong>松弛时间反映了完成某些任务时可以推迟其开始时间或延长完成时间</strong>，但是PERT图不能反映任务间的并行关系。</p></blockquote><h1 id="5-5-软件评审"><a href="#5-5-软件评审" class="headerlink" title="5.5 软件评审"></a>5.5 软件评审</h1><h3 id="1-软件质量的评审内容"><a href="#1-软件质量的评审内容" class="headerlink" title="1. 软件质量的评审内容"></a>1. 软件质量的评审内容</h3><ol><li>功能结构：在软件设计中占有极其重要的地位，软件评审时必须明确软件的数据结构，需检查的项目如下<ol><li>数据结构</li><li>功能结构</li><li>数据结构和功能结构之间的对应关系</li></ol></li><li>功能的通用性</li><li>模块的层次</li><li>模块结构</li></ol><h1 id="5-6-软件度量"><a href="#5-6-软件度量" class="headerlink" title="5.6 软件度量"></a>5.6 软件度量</h1><h3 id="1-McCabe-度量法"><a href="#1-McCabe-度量法" class="headerlink" title="1. McCabe 度量法"></a>1. McCabe 度量法</h3><blockquote><p>又称为环路度量，他认为循环和选择构成的环路越多，程序就越复杂。他把程序流程图中的每个处理符号都退化成为一个结点，原来连接不同处理符号的流线变成连接不同点的有向弧，这样得到的有向图称为<strong>程序图</strong>。</p></blockquote><p>*<em>McCabe环路复杂度: V(G) = m - n = 2 * p*</em></p><p><strong>m 是图G中弧的个数，n是图G的结点数，p是G中的强连通分量个数，通常取1</strong></p><p>ps: </p><ol><li>顶点强连通：有向图中u,v两点，u -&gt; v, v -&gt; u 都有一条有向的路径，则称这两点连通</li><li>强连通图：若所有节点都是强连通，则该图为强连通图</li><li>强连通分量：有向非连通图的极大强连通子图</li></ol><p>当环路复杂度超过10时，要充分测试这个模块就变得十分困难，</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/17/hello-world/"/>
      <url>2020/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

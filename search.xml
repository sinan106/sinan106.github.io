<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件工程</title>
      <link href="2020/12/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>2020/12/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h3 id="1-1-1-软件的定义"><a href="#1-1-1-软件的定义" class="headerlink" title="1.1.1 软件的定义"></a>1.1.1 软件的定义</h3><ol><li>指令的集合</li><li>数据结构</li><li>软件描述信息</li></ol><h4 id="软硬件失效图："><a href="#软硬件失效图：" class="headerlink" title="软硬件失效图："></a>软硬件失效图：</h4><img src="http://cdn.zhouxug.cn/20201219171313.jpg" alt="IMG_20201219_170723" style="zoom: 25%;" /><p>软件每次变更都会引入新的错误，可以说<strong>不断的变化是软件退化的根本原因</strong></p><h3 id="1-1-3-遗留软件"><a href="#1-1-3-遗留软件" class="headerlink" title="1.1.3 遗留软件"></a>1.1.3 遗留软件</h3><ol><li>维护代价高昂且系统演化风险较高</li><li>生命周期长且业务关键性</li><li>质量差，设计难以扩展，代码令人费解</li></ol><p><strong>最合理的方法也许是什么也不做</strong></p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h3 id="2-1-定义软件工程学科"><a href="#2-1-定义软件工程学科" class="headerlink" title="2.1 定义软件工程学科"></a>2.1 定义软件工程学科</h3><blockquote><p>将系统化的、规范的、可量化的方法应用于软件开发中、运行、维护中，将工程化的方法运用到软件中</p></blockquote><h4 id="层次结构定义："><a href="#层次结构定义：" class="headerlink" title="层次结构定义："></a>层次结构定义：</h4><p>由上到下：工具 -&gt; 方法 -&gt; 过程 -&gt; 质量关注点</p><img src="http://cdn.zhouxug.cn/20201219171330.jpg" alt="IMG_20201219_170736" style="zoom: 25%;" /><ol><li>支持软件工程的根基在与质量关注点</li><li>软件工程的基础是过程层，软件过程将各个技术层次的结合在一起，是的合理及时的开发软件成为了可能</li><li>软件工程方法为构建软件提供技术上的解决方法 </li><li>软件工程工具为工程和方法提供自动化或半自动化的支持</li></ol><h3 id="2-2-1-过程框架"><a href="#2-2-1-过程框架" class="headerlink" title="2.2.1 过程框架"></a>2.2.1 过程框架</h3><blockquote><p>一个通用的过程框架包含以下五个过程</p></blockquote><ol><li>沟通：与客户沟通，理解项目目标，收集需求以定义软件特性和功能</li><li>策划：创建一个“地图”，定义和描述了软件工程工作，包括需要执行的技术任务、可能的风险、资源需求、工作产品和工作进度计划</li><li>建模：利用模型更好的理解软件需求，并完成符合这些需求的软件设计</li><li>构建：编码和测试</li><li>部署：交付用户，对其评测并反馈意见</li></ol><h3 id="2-2-2-普适性活动"><a href="#2-2-2-普适性活动" class="headerlink" title="2.2.2 普适性活动"></a>2.2.2 普适性活动</h3><blockquote><p>普适性活动贯穿软件项目始终</p></blockquote><p>典型普适性活动如下：</p><ul><li>软件项目跟踪和控制：评估项目进度</li><li>风险管理</li><li>软件质量保证</li><li>技术评审：尽量在错误传播到下一个活动之前发现并解决</li><li>测量：帮助团队在发布式满足要求</li><li>软件配置管理</li><li>可复用管理</li><li>工作产品的准备和生产</li></ul><h3 id="2-4-软件开发神话-（判断题）"><a href="#2-4-软件开发神话-（判断题）" class="headerlink" title="2.4 软件开发神话 （判断题）"></a>2.4 软件开发神话 （判断题）</h3><p><strong>看书！！ p16</strong></p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h3 id="3-1-通用过程模型"><a href="#3-1-通用过程模型" class="headerlink" title="3.1  通用过程模型"></a>3.1  通用过程模型</h3><h4 id="过程流"><a href="#过程流" class="headerlink" title="过程流"></a>过程流</h4><ul><li><p>线性过程流</p></li><li><p>迭代过程流</p></li><li><p>演化过程流</p></li><li><p>并行过程流</p></li></ul><img src="http://cdn.zhouxug.cn/20201219171429.jpg" alt="IMG_20201219_170749" style="zoom: 25%;" /><h1 id="第四章-过程模型"><a href="#第四章-过程模型" class="headerlink" title="第四章 过程模型"></a>第四章 过程模型</h1><h3 id="4-1-惯用过程模型"><a href="#4-1-惯用过程模型" class="headerlink" title="4.1 惯用过程模型"></a>4.1 惯用过程模型</h3><ol><li><a href="https://sinan106.github.io/2020/10/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#1-%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B">瀑布模型</a></li><li><a href="https://sinan106.github.io/2020/10/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#2-%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B%E2%80%8B">增量模型</a></li><li><a href="https://sinan106.github.io/2020/10/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B">原型模型</a></li><li><a href="https://sinan106.github.io/2020/10/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/#4-%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B">螺旋模型</a></li></ol><h3 id="4-2-1-基于构件的开发"><a href="#4-2-1-基于构件的开发" class="headerlink" title="4.2.1 基于构件的开发"></a>4.2.1 基于构件的开发</h3><blockquote><p>具有许多螺旋模型的特点，它的本质是演化模型，以迭代的方式构建软件，不同的是采用预先打包的软件构件来开发应用（调SDK）</p></blockquote><h3 id="4-2-2-形式化方法模型"><a href="#4-2-2-形式化方法模型" class="headerlink" title="4.2.2 形式化方法模型"></a>4.2.2 形式化方法模型</h3><blockquote><p>主要是生成计算机软件形式化的数学规格说明</p></blockquote><p><strong>一个选择题答案：形式化方法</strong></p><h3 id="4-3-统一过程-UP"><a href="#4-3-统一过程-UP" class="headerlink" title="4.3 统一过程 UP"></a>4.3 统一过程 UP</h3><img src="http://cdn.zhouxug.cn/20201219171456.jpg" alt="IMG_20201219_170759" style="zoom:25%;" /><p><strong>统一过程的阶段与通用过程框架相通</strong></p><ol><li>起始阶段：包括沟通和策划</li><li>细化阶段：包括沟通和建模 ？</li><li>构建阶段：与通用过程框架相同</li><li>转换阶段：包括构建和部署</li><li>生产阶段：增量生产</li></ol><h1 id="第五章-敏捷开发"><a href="#第五章-敏捷开发" class="headerlink" title="第五章 敏捷开发"></a>第五章 敏捷开发</h1><h4 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h4><ul><li>个人和他人之间的<strong>交流</strong>胜过开发过程和文档</li><li>可运行的软件胜过宽泛的文档</li><li>客户合作胜过合同谈判</li><li>对变更的良好响应胜过按部就班的计划</li></ul><h3 id="5-3-敏捷及变更成本"><a href="#5-3-敏捷及变更成本" class="headerlink" title="5.3 敏捷及变更成本"></a>5.3 敏捷及变更成本</h3><img src="http://cdn.zhouxug.cn/20201219171507.jpg" alt="IMG_20201219_170808" style="zoom: 25%;" /><h3 id="5-4-极限编程-XP"><a href="#5-4-极限编程-XP" class="headerlink" title="5.4 极限编程 XP"></a>5.4 极限编程 XP</h3><h4 id="5-4-1极限编程过程"><a href="#5-4-1极限编程过程" class="headerlink" title="5.4.1极限编程过程"></a>5.4.1极限编程过程</h4><blockquote><p>它是敏捷开发中使用最广泛的一种方法</p></blockquote><img src="http://cdn.zhouxug.cn/20201219171547.jpg" alt="IMG_20201219_170710" style="zoom: 25%;" /><p>策划 -&gt; 设计 -&gt; 编码 -&gt; 测试</p><ol><li>策划：收集用户故事（需求），了解开发软件所需的功能和特性</li><li>设计：遵守 Keep It Simple 原则，不鼓励额外功能设计，鼓励使用CRC卡</li><li>编码：开发一系列用于检测本次发布的所有故事的单元测试；<strong>结对编程指的是XP建议两个人为同一个故事开发，以保证实时解决问题和代码及时复审</strong></li><li>测试：每当代码修改之后，及时进行回归测试，使用通用测试集，便于每天都可以进行系统集成和确认测试</li></ol><h4 id="5-4-2-工业极限编程-IXP"><a href="#5-4-2-工业极限编程-IXP" class="headerlink" title="5.4.2 工业极限编程 IXP"></a>5.4.2 工业极限编程 IXP</h4><blockquote><p>IXP 是 XP 的进化，它由<strong>XP的最低要求、以客户为中心和测试驱动精神组成</strong></p></blockquote><p>两者区别：IXP管理具有更大的包容性，他扩大了用户角色，升级了技术实践</p><h1 id="第六章-软件工程的人员方面"><a href="#第六章-软件工程的人员方面" class="headerlink" title="第六章 软件工程的人员方面"></a>第六章 软件工程的人员方面</h1><h3 id="6-4-团队结构"><a href="#6-4-团队结构" class="headerlink" title="6.4 团队结构"></a>6.4 团队结构</h3><blockquote><p>软件工程团队的四种模式</p></blockquote><ol><li>封闭模式：组成的团队遵循传统的权力层级模式，在做和以前相似的软件时效果很好，但是缺乏创新性</li><li>随机模式：团队是松散的，依靠团队成员的个人自发性，在需要创新和技术性突破式可以做的很优秀，但是很难保持有“秩序的操作”</li><li>开放模式：既有封闭模式的可控性，又有随机模式的创新性，适合解决复杂的问题，但是效率不高</li><li>同步模式：依赖于问题的自然区分，不需要过多的交流就能将成员组织在一起解决问题</li></ol><h1 id="第七章-理解需求"><a href="#第七章-理解需求" class="headerlink" title="第七章 理解需求"></a>第七章 理解需求</h1><h3 id="7-1-需求工程"><a href="#7-1-需求工程" class="headerlink" title="7.1 需求工程"></a>7.1 需求工程</h3><blockquote><p>致力于不断理解需求的大量任务和技术，开始于沟通并持续到建模活动</p></blockquote><p>7项任务：</p><ol><li>起始：建立基本的需求，包括存在的问题、谁需要解决方案、所期望解决方案的性质、与项目利益相关者和开发人员初步达成交流合作的效果</li><li>获取：建立商业目标，建立优先机制和潜在架构的合理性</li><li>细化：将起始和获取阶段的信息进行拓展个提炼</li><li>协商：若有用户提出了过高的要求，或不同客户间的需求相互冲突，通过协商阶段来进行调解</li><li>规格说明：文档、图形化模型、形式化数学模型、使用场景等中的一个</li><li>确认：对需求工程的工作产品进行质量评估</li><li>需求管理：帮助项目组在项目进展中表示、控制和跟踪需求以及需求变更的活动</li></ol><p>PS：软件需求规格说明书/SRS：在项目商业化之前必须建立的详细描述软件各个方面的工作产品</p><h3 id="7-3-2-质量功能部署-QFD"><a href="#7-3-2-质量功能部署-QFD" class="headerlink" title="7.3.2 质量功能部署 QFD"></a>7.3.2 质量功能部署 QFD</h3><blockquote><p>QFD是一种将用户需求转化为软件需求的技术</p></blockquote><p>分为3个需求：</p><ol><li>常规需求：若这些需求存在，用户会满意</li><li>期望需求：客户没有清晰表达的基础功能，但是缺少了客户会不满</li><li>兴奋需求：超出客户需求，当这些需求存在时客户会很满意</li></ol><p>SafeHome 住宅安全系统UML用例图</p><p>插图 p88</p><h3 id="7-5-分析模型的元素"><a href="#7-5-分析模型的元素" class="headerlink" title="7.5 分析模型的元素"></a>7.5 分析模型的元素</h3><ol><li>基于场景的元素：从用户的角度描述系统</li><li>基于类的元素：每个使用场景都意味着当一个参与者和系统交互时所操作的一组对象</li><li>行为元素：状态图是一种表现系统行为的方法</li><li>数据流元素</li></ol><h1 id="第八章-基于场景的需求建模"><a href="#第八章-基于场景的需求建模" class="headerlink" title="第八章 基于场景的需求建模"></a>第八章 基于场景的需求建模</h1><blockquote><p>开发用例图时应列出特定参与者执行的活动和功能</p><p>用例图包括：参与者、用例、系统边界、箭头</p></blockquote><p>SafeHome系统的初步用例图</p><img src="http://cdn.zhouxug.cn/20201220234651.jpg" alt="IMG_20201220_233123" style="zoom:25%;" /><h3 id="8-3-活动图"><a href="#8-3-活动图" class="headerlink" title="8.3 活动图"></a>8.3 活动图</h3><blockquote><p>活动图在特定场景内通过提供迭代流的图形化表示来补充用例</p></blockquote><p>通过互联网访问摄像机监视设备并显示摄像机视图功能的活动图</p><img src="http://cdn.zhouxug.cn/20201220234643.jpg" alt="IMG_20201220_233120" style="zoom:25%;" /><h3 id="8-4-泳道图"><a href="#8-4-泳道图" class="headerlink" title="8.4 泳道图"></a>8.4 泳道图</h3><blockquote><p>允许建模人员表示用力所示描述的活动流，同时指出参与者或分析类负责由活动举行所描述的活动。</p></blockquote><p>通过互联网访问摄像机监视设备并显示摄像机视图功能的泳道图</p><img src="http://cdn.zhouxug.cn/20201220234631.jpg" alt="IMG_20201220_233112" style="zoom:25%;" /><h1 id="第九章-基于类的需求建模"><a href="#第九章-基于类的需求建模" class="headerlink" title="第九章 基于类的需求建模"></a>第九章 基于类的需求建模</h1><h3 id="9-1-识别分析类-语法分析"><a href="#9-1-识别分析类-语法分析" class="headerlink" title="9.1 识别分析类 / 语法分析"></a>9.1 识别分析类 / 语法分析</h3><p>​        检查需求模型开发的使用场景，并对系统开发的用例进行“语法解析”，即可开始识别类分析。带有下划线的每个名词可以确定为类，将这些名词输入到一个简单表中并标出同义词。如果要求某个类实现一个解决方案，那么这个类就是解决方案空间的一部分；否则，如果只要求某个类描述一个解决方案，那么这个类就是问题空间的一部分。</p><h3 id="9-4-CRC-类-职责-协作者-建模"><a href="#9-4-CRC-类-职责-协作者-建模" class="headerlink" title="9.4 CRC / 类-职责-协作者 建模"></a>9.4 CRC / 类-职责-协作者 建模</h3><blockquote><p>实际上时表示类的标准索引卡片的集合。这些卡片分为三部分，顶部写类名，主体左侧列出类的职责，右侧写类的协作者</p></blockquote><img src="http://cdn.zhouxug.cn/20201220234608.jpg" style="zoom:25%;" /><ul><li>类：<ul><li>实体类：代表保存在数据库中和贯穿在应用程序中的事务</li><li>边界类：用于创建用户可见的何在使用软件交互的接口，职责是管理实体对象呈现给用户的方式</li><li>控制类：是管理“工作单元”，</li></ul></li><li>职责：类似功能</li><li>协作：当实现某个职责需要和其他类进行交互就有协作</li></ul><h4 id="类关联的种类-类之间的通用关系"><a href="#类关联的种类-类之间的通用关系" class="headerlink" title="类关联的种类 / 类之间的通用关系"></a>类关联的种类 / 类之间的通用关系</h4><ol><li>is-part-of</li><li>has-knowledge-of / 有…知识：当一个类必须从另一个类获取信息时</li><li>depends-upon / 依赖</li></ol><h1 id="第十章-需求建模：行为和模式"><a href="#第十章-需求建模：行为和模式" class="headerlink" title="第十章 需求建模：行为和模式"></a>第十章 需求建模：行为和模式</h1><h3 id="10-2-识别用例事件"><a href="#10-2-识别用例事件" class="headerlink" title="10.2 识别用例事件"></a>10.2 识别用例事件</h3><blockquote><p>系统和参与者之间交换了信息就发生了事件，事件时已交换信息的事实</p></blockquote><h3 id="10-3-状态表达"><a href="#10-3-状态表达" class="headerlink" title="10.3 状态表达"></a>10.3 状态表达</h3><ul><li>主动状态：对象进行持续变换或处理时的当前状态</li><li>被动状态：某个对象所有属性的当前状态</li></ul><h4 id="1-状态图"><a href="#1-状态图" class="headerlink" title="1. 状态图"></a>1. 状态图</h4><blockquote><p>一种行为图，呈现了主动状态和导致这些主动状态发生的事件</p></blockquote><p>ControlPanel状态图</p><img src="http://cdn.zhouxug.cn/20201220234558.jpg" alt="IMG_20201220_233039" style="zoom:25%;" /><p>箭头表示某个对象从一个主动状态转移到另一个主动状态，箭头上的标注是转移事件</p><h4 id="2-顺序图"><a href="#2-顺序图" class="headerlink" title="2. 顺序图"></a>2. 顺序图</h4><blockquote><p>表明事件如何引发从一个对象到另一个对象的转移</p></blockquote><p>SafeHome 安全功能顺序图</p><img src="http://cdn.zhouxug.cn/20201220234536.jpg" style="zoom:25%;" /><h1 id="第十一章-设计概念"><a href="#第十一章-设计概念" class="headerlink" title="第十一章 设计概念"></a>第十一章 设计概念</h1><h3 id="11-2-1-质量属性"><a href="#11-2-1-质量属性" class="headerlink" title="11.2.1 质量属性"></a>11.2.1 质量属性</h3><ul><li>功能性</li><li>易用性</li><li>可靠性</li><li>性能</li><li>可维护性 / 可支持性</li></ul><h3 id="11-3-10-重构"><a href="#11-3-10-重构" class="headerlink" title="11.3.10 重构"></a>11.3.10 重构</h3><blockquote><p>一种重新组织的技术，可以简化构建的设计而无需改变其功能和行为</p><p>定义：一种不改变代码的外部行为而是改进其内部结构的软件系统过程</p></blockquote><h3 id="11-3-12-组织良好的设计类的四个特征"><a href="#11-3-12-组织良好的设计类的四个特征" class="headerlink" title="11.3.12 组织良好的设计类的四个特征"></a>11.3.12 组织良好的设计类的四个特征</h3><ol><li>完整性与充分性：完整的封装所有可以合理遇见的存在于类中的属性和方法</li><li>原始性：一个类相关的方法应关注于实现类的某一个服务，不为同一职责提供两种方法</li><li>高内聚性：具有小而集中的职责机制，并且关注于使用属性和方法来实现这些职责</li><li>低耦合性：将类间的合作保持在一个可以接受的小范围内</li></ol><h1 id="第十二章-体系结构设计"><a href="#第十二章-体系结构设计" class="headerlink" title="第十二章 体系结构设计"></a>第十二章 体系结构设计</h1><h3 id="12-3-1-体系结构风格的简单分类"><a href="#12-3-1-体系结构风格的简单分类" class="headerlink" title="12.3.1 体系结构风格的简单分类"></a>12.3.1 体系结构风格的简单分类</h3><ol><li><p>以数据为中心的体系结构：数据存储位于这种体系结构的中心，其他构件会经常访问数据存储</p> <img src="http://cdn.zhouxug.cn/20201220234421.jpg" alt="IMG_20201220_233000" style="zoom:25%;" /></li><li><p>数据流体系结构调用和返回体系结构：输入数据经过一系列计算构建和操作构件的变换形成输出数据</p> <img src="http://cdn.zhouxug.cn/20201220234430.jpg" alt="IMG_20201220_233003" style="zoom:25%;" /></li><li><p>调用和返回体系结构</p><ol><li><p>主程序 / 子程序体系结构：将功能分为一个控制层次，程序按层次调用</p> <img src="http://cdn.zhouxug.cn/20201220234449.jpg" alt="IMG_20201220_233010" style="zoom:25%;" /></li><li><p>远程调用体系结构：将主 / 子程序的构件分布在多台计算机上</p></li></ol></li><li><p>面向对象体系结构：构件中封装了数据和必须用于控制该数据的操作</p></li><li><p>层次体系结构：定义一系列不同的层次，每个层次各自完成操作，逐渐接近机器的指令集</p></li></ol><img src="http://cdn.zhouxug.cn/20201220234516.jpg" alt="IMG_20201220_233012" style="zoom:25%;" /><h1 id="第十三章-构件级设计"><a href="#第十三章-构件级设计" class="headerlink" title="第十三章 构件级设计"></a>第十三章 构件级设计</h1><h3 id="13-1-构件"><a href="#13-1-构件" class="headerlink" title="13.1 构件"></a>13.1 构件</h3><blockquote><p>系统中模块化的、可部署的、可替换的构件，该部件封装了实现并对外提供一组接口</p></blockquote><h3 id="13-1-1-面向对象观点"><a href="#13-1-1-面向对象观点" class="headerlink" title="13.1.1 面向对象观点"></a>13.1.1 面向对象观点</h3><blockquote><p>构件包括一个协作类的集合，构件中的每个类都得到详细阐述，包括所有属性和与其实现相关的操作，并定义所有与其他设计类相互通信协作的接口</p></blockquote><img src="http://cdn.zhouxug.cn/20201220234351.jpg" alt="IMG_20201220_232945" style="zoom:25%;" /><h3 id="13-1-2-传统观点"><a href="#13-1-2-传统观点" class="headerlink" title="13.1.2 传统观点"></a>13.1.2 传统观点</h3><blockquote><p>一个构件就是程序的一个功能要素，程序由处理逻辑及实现处理逻辑所需的内部数据结构以及构件被调用和实现数据传递的接口构成</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://cdn.zhouxug.cn/20201220234322.jpg" alt="IMG_20201220_232941" style="zoom: 25%;" /></h3><h3 id="13-2-构件的基本设计原则"><a href="#13-2-构件的基本设计原则" class="headerlink" title="13.2 构件的基本设计原则"></a>13.2 构件的基本设计原则</h3><blockquote><p>这些原则的根本动机在于</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 考试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET</title>
      <link href="2020/11/29/NET/"/>
      <url>2020/11/29/NET/</url>
      
        <content type="html"><![CDATA[<h1 id="1-选择判断"><a href="#1-选择判断" class="headerlink" title="1. 选择判断"></a>1. 选择判断</h1><h3 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1. HTML"></a>1. HTML</h3><ol><li><p>常见块级元素和行内元素：</p><ol><li>div：块级元素，没有特定含义，通常用于逻辑上的分块，会换行 ，</li><li>span：行内元素，无特殊含义，可作为文本容器，不会换行</li><li>table：块级元素，是HTML表格，会换行<img src="C:\Users\zhoux\AppData\Roaming\Typora\typora-user-images\image-20201129110949676.png" alt="image-20201129110949676" style="zoom: 67%;" /></li><li>form：块级元素，会换行</li></ol></li><li><p>ul、ol标签区别</p><ol><li>ul是无序列表，使用list-style-type:none可以去掉实心圆 <img src="http://cdn.zhouxug.cn/20201129111459.png" alt="image-20201129111459633" style="zoom:67%;" /></li><li>ol是有序列表，可以设置 start = “100” 是的序号从100开始 <img src="http://cdn.zhouxug.cn/20201129111512.png" alt="image-20201129111512154" style="zoom:67%;" /></li><li>以上两者内部都是用li标签</li></ol></li><li><p>video标签支持的格式：mp4,webm,ogg三种格式</p></li><li><p>input常用属性</p><ol><li>name：传值必须使用name，否则该数据不会被提交</li><li>使用get方法会在url后以?连接请求串，多个值之间使用&amp;相连</li><li>value：初始值</li><li>title：悬浮提示</li><li>autofocus：获得焦点</li><li>placeholder：站位提示，输入会自动消失</li><li>type：<ol><li>text：单行文本框，搭配maxlength表示接收的最长字符</li><li>password：密码</li><li>checkbox：复选框，收到的内容为 name = value，<img src="http://cdn.zhouxug.cn/20201129113148.png" alt="image-20201129113148280" style="zoom:80%;" /></li><li>hidden：隐藏域，有name值的隐藏域会和其value一起提交</li><li>submit：提交</li><li>reset：重填</li></ol></li></ol></li><li><p>form表单</p><ol><li><p>概览</p><img src="http://cdn.zhouxug.cn/20201129112040.png" alt="image-20201129112040621" style="zoom: 50%;" /></li><li><p>target = “_blank” 是从新窗口打开页面，默认是 target = “_self”，从当前页面打开</p></li><li></li></ol></li></ol><h1 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2. CSS"></a>2. CSS</h1><blockquote><p>样式定义如何显示HTML元素，解决内容与表现分离的问题</p></blockquote><h3 id="1-常用选择器"><a href="#1-常用选择器" class="headerlink" title="1. 常用选择器"></a>1. 常用选择器</h3><ol><li>通配符选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>标签选择器</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">input</span>&#123;</span><br><span class="line">    <span class="attribute">background-color </span>: silver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>id选择器</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">id</span> &#123;</span><br><span class="line">    <span class="attribute">background-color </span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>class选择器</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>标签 class组合选择器</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.class &#123;&#125; // 注意选择器之间没有空格</span><br></pre></td></tr></table></figure><ol start="6"><li>后代选择器</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ul li a &#123;            //空格分隔选择器 可以跨代</span><br><span class="line">color:red; //本例含义 ul后代的li后代的a标签字体为红色</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.wust.edu.cn/&quot;</span>&gt;</span>武科大<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.hust.edu.cn/&quot;</span>&gt;</span>华科<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.whu.edu.cn/&quot;</span>&gt;</span>武大<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>子选择器（<strong>直接儿子</strong>）</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&gt;strong &#123;           // div 所有直接儿子为strong元素字体为红色 </span><br><span class="line">    <span class="selector-tag">color</span> : <span class="selector-tag">red</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>相邻兄弟选择器</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h3+p &#123;&#125;  // 选择紧跟在另一元素后的元素(第一个相邻的) ，二者有相同父元素</span><br></pre></td></tr></table></figure><ol start="9"><li>同级兄弟选择器</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h3~p&#123;&#125;  // 选择同级的元素(后面相邻的兄弟)，二者有相同父元素</span><br></pre></td></tr></table></figure><ol start="10"><li>伪类</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// 1. a标签</span><br><span class="line">&lt;a href=&quot;http://www.wust.edu.cn&quot; target=&quot;_blank&quot;&gt;武科大&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="comment">/* 未访问的链接 */</span></span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="comment">/* 已访问的链接 */</span></span><br><span class="line"><span class="attribute">color</span>: grey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="comment">/* 鼠标移动到链接上 */</span></span><br><span class="line"><span class="attribute">color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="comment">/* 选定的链接(鼠标按下时) */</span></span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. focus</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">form</span>&gt;</span><br><span class="line">用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">密码: &lt;input type=&quot;text&quot; name=&quot;psd&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">// 3. first-child</span><br><span class="line">p:first-child &#123;    //作为第一个子元素的 p 元素</span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;p&gt;第一段&lt;/p&gt; // 变红</span><br><span class="line">&lt;p&gt;第二段&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">// 4. before在元素之前插入新内容</span><br><span class="line">h1:before &#123;  //含义：在 h1 元素之前添加内容</span><br><span class="line">content: url(&quot;images/1.gif&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;h1&gt;武汉科技大学&lt;/h1&gt;</span><br><span class="line">// tips: 在css3中推荐写法为 ::before ::after</span><br></pre></td></tr></table></figure><h3 id="2-常用属性"><a href="#2-常用属性" class="headerlink" title="2. 常用属性"></a>2. 常用属性</h3><h4 id="1-背景属性"><a href="#1-背景属性" class="headerlink" title="1. 背景属性"></a>1. 背景属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">    // 颜色</span><br><span class="line">    <span class="selector-tag">background-color</span> : <span class="selector-tag">red</span>;</span><br><span class="line">    </span><br><span class="line">    // 图片</span><br><span class="line">    background-image : url(image/1.jpg); // 没有引号</span><br><span class="line">    backgroung-repeat : no-repeat; // 背景图片仅显示一次 </span><br><span class="line">       // 默认为 repeat 背景图片将在垂直和水平方向重复</span><br><span class="line">    background-attachment : fixed; // 页面滚动时，背景图不会滚动 </span><br><span class="line">                                   // 默认为scroll 会滚动</span><br><span class="line">    // 上述三种属性可简写为 </span><br><span class="line">    background : url(image/1.jpg) no-repeat fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-字体属性"><a href="#2-字体属性" class="headerlink" title="2. 字体属性"></a>2. 字体属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">font-family: 黑体,arial,sans-serif;   //如果浏览器不支持第一个字体，则会尝试下一个</span><br><span class="line">font-style: italic; //字体样式 分为 normal italic 斜体 oblique 倾斜 </span><br><span class="line">font-weight: bold;  //字体粗细</span><br><span class="line">line-height: 30px;  //行高</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-文本属性"><a href="#3-文本属性" class="headerlink" title="3. 文本属性"></a>3. 文本属性</h4><ol><li>文字居中</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.center</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: silver;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center; </span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;center&quot;&gt;武汉科技大学&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cdn.zhouxug.cn/20201129151930.png" alt="image-20201129151930663"></p><ol start="2"><li>文字水平居中</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.center</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: silver;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">50px</span>; </span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">line-height: 50px;  // 字体行高与 div的行高相同 则文字可以垂直居中</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>图片居中</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">这是一幅&lt;img src=&quot;images/1.gif&quot; /&gt;位于段落中的图像。</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 操作系统</title>
      <link href="2020/10/30/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2020/10/30/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="4-1-操作系统分类及特点"><a href="#4-1-操作系统分类及特点" class="headerlink" title="4.1 操作系统分类及特点"></a>4.1 操作系统分类及特点</h1><h3 id="1-批处理操作系统"><a href="#1-批处理操作系统" class="headerlink" title="1. 批处理操作系统"></a>1. 批处理操作系统</h3><h4 id="1-单道批操作系统"><a href="#1-单道批操作系统" class="headerlink" title="1. 单道批操作系统"></a>1. 单道批操作系统</h4><blockquote><p>指一次只有一个作业装入内存执行，当一个结束后，才会调入第二个</p></blockquote><h4 id="2-多道批操作系统"><a href="#2-多道批操作系统" class="headerlink" title="2. 多道批操作系统"></a>2. 多道批操作系统</h4><blockquote><p>允许多个作业装入内存执行，在任意时刻作业都处于开始点和终止点之间。每当运行中的一个作业因I / O操作停止时，CPU就会交给另一个等待运行的作业，从而将<strong>主机与外设之间的工作由串行改为并行</strong>，提高执行效率。</p></blockquote><p>特点：</p><ul><li>多道</li><li>宏观并行</li><li>微观串行</li></ul><h3 id="2-分时操作系统"><a href="#2-分时操作系统" class="headerlink" title="2. 分时操作系统"></a>2. 分时操作系统</h3><blockquote><p>将CPU划分成很多很短的时间片，轮流为各个终端用户服务，如UNIX</p></blockquote><h3 id="3-实时操作系统"><a href="#3-实时操作系统" class="headerlink" title="3. 实时操作系统"></a>3. 实时操作系统</h3><blockquote><p>要求计算机能对外来信息以足够快的速度处理，并且能够在对象允许的时间之内做出反应</p></blockquote><p>分为两类：</p><ol><li>实时控制系统：主要用于生产过程的自动控制</li><li>实时信息处理系统：：主要用于实时信息处理</li></ol><h1 id="4-2-进程管理"><a href="#4-2-进程管理" class="headerlink" title="4.2 进程管理"></a>4.2 进程管理</h1><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><h4 id="1-进程与程序"><a href="#1-进程与程序" class="headerlink" title="1. 进程与程序"></a>1. 进程与程序</h4><blockquote><p>进程是程序的一次执行，该程序可以和其他程序并发执行，由程序、数据、PCB（进程控制块）构成</p></blockquote><ul><li>PCB是进程存在的唯一标识，包含进程的描述信息和控制信息</li><li>程序描述了进程需要完成的功能</li><li>数据则是包含了进程所需的数据及工作区</li></ul><h4 id="2-进程的状态及其状态间的切换"><a href="#2-进程的状态及其状态间的切换" class="headerlink" title="2. 进程的状态及其状态间的切换"></a>2. 进程的状态及其状态间的切换</h4><h4 id="1-三态模型"><a href="#1-三态模型" class="headerlink" title="1. 三态模型"></a>1. 三态模型</h4><blockquote><p>包含运行、就绪和阻塞状态</p></blockquote><ol><li>运行</li><li>就绪：该进程获得了除处理机以外的所有资源，一旦得到就可以运行</li><li>阻塞：该进程正在等待某事件的发生，如IO</li></ol><h4 id="2-五态模型"><a href="#2-五态模型" class="headerlink" title="2. 五态模型"></a>2. 五态模型</h4><blockquote><p>三态模型加上新建和终止模型</p></blockquote><ol><li><p>新建：进程刚刚被创建而没有被提交的状态，并等待系统创建进程的所有必要条件。创建分为两个子状态</p><ol><li><p>为该进程创建必要的管理信息</p></li><li><p>让该进程进入就绪状态</p><p><img src="http://cdn.zhouxug.cn/20201030171326.png" alt="image-20201030171326253"></p></li></ol></li><li><p>终止</p><ol><li>等待操作系统进行善后处理</li><li>释放主存<br><img src="http://cdn.zhouxug.cn/20201030171335.png" alt="image-20201030171335392"></li></ol></li></ol><h4 id="3-具有挂起状态的进程状态及转换"><a href="#3-具有挂起状态的进程状态及转换" class="headerlink" title="3. 具有挂起状态的进程状态及转换"></a>3. 具有挂起状态的进程状态及转换</h4><ol><li>活跃就绪：进程在主存且处于可被调度的状态</li><li>静止就绪：在辅存</li><li>活跃阻塞：在主存，等待事件产生就进入活跃就绪</li><li>静止阻塞：辅存</li></ol><p><img src="http://cdn.zhouxug.cn/20201030171646.png" alt="image-20201030171646878"></p><h3 id="2-进程的控制"><a href="#2-进程的控制" class="headerlink" title="2. 进程的控制"></a>2. 进程的控制</h3><blockquote><p>进程的控制是由操作系统内核中的原语实现的。</p></blockquote><ul><li><p>内核是计算机系统硬件的首次延伸，它是基于硬件的第一层软件扩充。</p></li><li><p>原语是若干条机器指令组成的，他是原子操作，要么都做，要么不做</p></li></ul><h3 id="3-进程的通信"><a href="#3-进程的通信" class="headerlink" title="3. 进程的通信"></a>3. 进程的通信</h3><h4 id="1-同步与互斥"><a href="#1-同步与互斥" class="headerlink" title="1. 同步与互斥"></a>1. 同步与互斥</h4><ol><li>同步指一些需要相互合作、协同工作的进程</li><li>互斥指多个进程争抢临界资源而互斥执行</li></ol><h4 id="2-信号量机制"><a href="#2-信号量机制" class="headerlink" title="2. 信号量机制"></a>2. 信号量机制</h4><p>信号量分为：</p><ul><li>公用信号量：实现进程间的互斥，初值为1或资源数目</li><li>私用信号量：实现进程间的同步，初值为0或某各正整数</li></ul><p>P、V操作</p><ul><li>P操作：S -= 1，若S  &gt;= 0 则继续执行，否则将该进程设置为阻塞状态并插入阻塞队列</li><li>V操作：S += 1，若S &gt; 0 则继续执行，否则从阻塞队列唤醒一个进程，插入就绪队列</li></ul><p>利用PV进行互斥：将信号量设置为1，进入P退出V</p><p>利用PV进行同步：信号量为0表示信息未产生，非0则是表示该消息已存在</p><h3 id="3-进程调度"><a href="#3-进程调度" class="headerlink" title="3 进程调度"></a>3 进程调度</h3><h4 id="1-调度方式"><a href="#1-调度方式" class="headerlink" title="1. 调度方式"></a>1. 调度方式</h4><blockquote><p>指当有更高优先级的进程到来时应该如何分配CPU</p></blockquote><p>调度分为可剥夺式和不可剥夺式：</p><ul><li>可剥夺式：当有更高优先级进程到来时，强行将正在运行的进程所占用的CPU分配给更高优先级</li><li>不可剥夺式：当有更高级进程到来时，必须等待正在运行的进程自动释放CPU，才能分配给更高级的进程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-综述"><a href="#1-综述" class="headerlink" title="1. 综述"></a>1. 综述</h1><blockquote><p>软件设计模式使人们可以更加简单方便复用成功的设计和体系结构</p></blockquote><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><blockquote><p>设计模式有两种分类方法，一种根据模式的目的来分；另一种根据模式的作用来分。</p></blockquote><p><img src="http://cdn.zhouxug.cn/20201024215450.png" alt="image-20201024215450877"></p><h3 id="2-23种设计模式概述"><a href="#2-23种设计模式概述" class="headerlink" title="2. 23种设计模式概述"></a>2. 23种设计模式概述</h3><ol><li>单例（Singleton）模式</li></ol><p>某个类只能生成一个实例，该类提供了一个全局访问点，供外部获取该实例，其拓展是有限多个实例。</p><ol start="2"><li>原型（Prototype）模式</li></ol><p>将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</p><ol start="3"><li>工厂方法（Factory Method）模式</li></ol><p>定义一个用户创建产品的接口，有子类决定生产什么产品。</p><ol start="4"><li>抽象工厂（Abstract Factory）模式</li></ol><p>提供一个创建产品族的接口，其每个子类可以生产一些列相关的产品。</p><ol start="5"><li>建造者（Builder）模式</li></ol><p>将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p><ol start="6"><li>代理（Proxy）模式</li></ol><p>为某个对象提供一种代理以控制对对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特征。</p><ol start="7"><li>适配器（Adapter）模式</li></ol><p>将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><ol start="8"><li>桥接（Bridge）模式</li></ol><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低 抽象和实现这两个可变维度的耦合度。<br>9. 装饰（Decorator）模式</p><p>动态的给对象增加一些职责，即增加其额外的功能。<br>10. 外观（Facade）模式</p><p>为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</p><ol start="11"><li>享元（Flyweight）模式</li></ol><p>运用共享技术来有效地支持大量细粒度对象的复用。</p><ol start="12"><li>组合（Composite）模式</li></ol><p>将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p><ol start="13"><li>模板方法（Template Method）模式</li></ol><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特点步骤。</p><ol start="14"><li>策略（Strategy）模式</li></ol><p>定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响算法的客户。</p><ol start="15"><li>命令（Command）模式</li></ol><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p><ol start="16"><li>职责链（Chain of Responsibility）模式</li></ol><p>把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这个方式去除对象之间的耦合。</p><ol start="17"><li>状态（State）模式</li></ol><p>允许一个对象在其内部状态发生改变时改变其行为能力。</p><ol start="18"><li>观察者（Observer）模式</li></ol><p>多个对象间存在一对多的关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其它对象的行为。</p><ol start="19"><li>中介者（Mediator）模式</li></ol><p>定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象的耦合度，使原有对象之间不必户互了解。</p><ol start="20"><li>迭代器（Iterator）模式</li></ol><p>提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</p><ol start="21"><li>访问者（Visitor）模式</li></ol><p>在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象。</p><ol start="22"><li>备忘录（Memento）模式</li></ol><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后回复它。</p><ol start="23"><li>解释器（Interpreter）</li></ol><p>提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p><h1 id="2-创建型设计模式"><a href="#2-创建型设计模式" class="headerlink" title="2. 创建型设计模式"></a>2. 创建型设计模式</h1><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><blockquote><p>在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的单例模式。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p></blockquote><p>单例模式有以下3个特点：</p><ol><li><p>单例类只有一个对象；</p></li><li><p>该单例对象必须由单例类自行创建；</p></li><li><p>单例类对外提供一个访问该单例的全局访问点。</p></li></ol><h4 id="1-1-单例模式的结构与实现"><a href="#1-1-单例模式的结构与实现" class="headerlink" title="1.1 单例模式的结构与实现"></a>1.1 单例模式的结构与实现</h4><blockquote><p>通常，普通类的结构函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法通过调用该类的构造函数，也就无法生成多个实例。这是该类自身必须定义一个静态私有实例，并向外提供一个讲台的公有函数用于创建或获取静态私有实例。</p></blockquote><p>下面分析单例模式的实现。</p><p>单例模式有懒汉式和饿汉式两种实现形式。</p><h5 id="1-1-1-懒汉式"><a href="#1-1-1-懒汉式" class="headerlink" title="1.1.1 懒汉式"></a>1.1.1 懒汉式</h5><blockquote><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getInstance() 方法才去创建单例。代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>注意：如果编写的是多线程程序，则不要删除上例代码中的关键字 volatile 和 synchronized，否则将存在线程非安全的问题。如果不删除这两个关键字就能保证线程安全，但是每次访问时都要同步，会影响性能，且消耗更多的资源，这是懒汉式单例的缺点。</u></p><h5 id="1-1-2-饿汉式"><a href="#1-1-2-饿汉式" class="headerlink" title="1.1.2 饿汉式"></a>1.1.2 饿汉式</h5><blockquote><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>饿汉式单例在类 创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，以后线程安全的，可以直接用于多线程而不会出现问题。</u></p><h4 id="1-2-单例模式的应用场景"><a href="#1-2-单例模式的应用场景" class="headerlink" title="1.2 单例模式的应用场景"></a>1.2 单例模式的应用场景</h4><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul><h4 id="1-3-单例模式的拓展"><a href="#1-3-单例模式的拓展" class="headerlink" title="1.3 单例模式的拓展"></a>1.3 单例模式的拓展</h4><blockquote><p>单例模式可扩展为有效的多例（Multiple）模式，这种模式可以生成有限个实例并保存在 ArrayList 中，客户需要时可随机获取，其结构如图2-1所示。</p></blockquote><p><img src="http://cdn.zhouxug.cn/20201024221526.png" alt="image-20201024221526320"></p><h3 id="2-原型模式"><a href="#2-原型模式" class="headerlink" title="2. 原型模式"></a>2. 原型模式</h3><blockquote><p>在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函方法创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。</p><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。这种方式创建对象非常高效，根本无需指定对象创建的细节。例如，Windows 操作系统的安装通常比较耗时，如果复制就快了很多。</p></blockquote><h4 id="2-1-原型模式的结构与实现"><a href="#2-1-原型模式的结构与实现" class="headerlink" title="2.1 原型模式的结构与实现"></a>2.1 原型模式的结构与实现</h4><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p><h5 id="2-1-1-模式的结构"><a href="#2-1-1-模式的结构" class="headerlink" title="2.1.1 模式的结构"></a>2.1.1 模式的结构</h5><p>原型模式包含以下主要角色：</p><ul><li><p>抽象原型类：规定了具体原型对象必须实现的接口。java中为Cloneable()接口</p></li><li><p>具体实现类：实现抽象原型类的 clone() 方法，它使可被复制的对象。</p></li><li><p>访问类：使用具体原型类中的 clone() 方法来复制新对象。</p></li></ul><h5 id="2-1-2-模式的实现"><a href="#2-1-2-模式的实现" class="headerlink" title="2.1.2 模式的实现"></a>2.1.2 模式的实现</h5><p>原型模式的克隆分为浅克隆和深克隆，Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    Realizetype() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Realizetype obj1=<span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone(); <span class="comment">// clone返回Object类，要强转</span></span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span>+(obj1==obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 具体原型创建成功！</span></span><br><span class="line"><span class="comment">// 具体原型复制成功！</span></span><br><span class="line"><span class="comment">// obj1==obj2?false</span></span><br></pre></td></tr></table></figure><h5 id="2-1-3-原型模式的应用实例"><a href="#2-1-3-原型模式的应用实例" class="headerlink" title="2.1.3 原型模式的应用实例"></a>2.1.3 原型模式的应用实例</h5><p>用原型模式除了可以生成相同的对象，还可以生成相似的对象，如以下实例：</p><blockquote><p>分析：同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，属于相似对象的复制，同样可以用原型模式创建，然后再做简单修改就可以了。图 4 所示是三好学生奖状生成器的结构图。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奖状类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">citation</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    String info;</span><br><span class="line">    String college;</span><br><span class="line">    citation(String name,String info,String college) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">        <span class="keyword">this</span>.college = college;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖状创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name+info+college);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奖状拷贝成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (citation)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoTypeCitation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        citation obj1 = <span class="keyword">new</span> citation(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;同学：在2016学年第一学期中表现优秀，被评为三好学生。&quot;</span>,<span class="string">&quot;韶关学院&quot;</span>);</span><br><span class="line">        obj1.display();</span><br><span class="line">        citation obj2 = (citation) obj1.clone();</span><br><span class="line">        obj2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        obj2.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 奖状创建成功！</span></span><br><span class="line"><span class="comment">// 张三同学：在2016学年第一学期中表现优秀，被评为三好学生。韶关学院</span></span><br><span class="line"><span class="comment">// 奖状拷贝成功！</span></span><br><span class="line"><span class="comment">// 李四同学：在2016学年第一学期中表现优秀，被评为三好学生。韶关学院</span></span><br></pre></td></tr></table></figure><h5 id="2-1-5-原型模式应用场景"><a href="#2-1-5-原型模式应用场景" class="headerlink" title="2.1.5 原型模式应用场景"></a>2.1.5 原型模式应用场景</h5><p>原型模式通常适用于以下场景。</p><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候，</li><li>对象的创建过程比较麻烦，但复制比较简单的时候。</li></ul><h5 id="2-1-6-原型模式的拓展"><a href="#2-1-6-原型模式的拓展" class="headerlink" title="2.1.6 原型模式的拓展"></a>2.1.6 原型模式的拓展</h5><blockquote><p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。</p></blockquote><p><img src="http://cdn.zhouxug.cn/20201025212553.png" alt="image-20201025212553490"></p><h3 id="3-工厂方法模式-仅针对一类产品"><a href="#3-工厂方法模式-仅针对一类产品" class="headerlink" title="3. 工厂方法模式 // 仅针对一类产品"></a>3. 工厂方法模式 // 仅针对一类产品</h3><blockquote><p>定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><p>我们把被创建的对象成为“产品”，把创建产品的对象成为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于23种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。</p><p>本节介绍的“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以是系统自不修改原来代码的情况下引进新的产品，即满足开闭原则。</p></blockquote><p>工厂方法模式的主要优点有：</p><ul><li>用户只需要指导具体工厂的名称就可以得到所需要的产品，无需知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无需对原工厂进行任何修改，满足开闭原则。</li></ul><p>缺点是：</p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h4 id="3-1-工厂方法模式的结构与实现"><a href="#3-1-工厂方法模式的结构与实现" class="headerlink" title="3.1 工厂方法模式的结构与实现"></a>3.1 工厂方法模式的结构与实现</h4><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成。</p><h5 id="3-1-1-模式结构"><a href="#3-1-1-模式结构" class="headerlink" title="3.1.1 模式结构"></a>3.1.1 模式结构</h5><p>工厂方法模式的主要角色如下：</p><ol><li><p>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品；</p></li><li><p>具体工厂（Concrete Factory）：主要是实现抽象工厂中的抽象方法，具体产品的创建；</p></li><li><p>抽象产品（Product）：定义了产品的规范，描述了产品的主要特征和功能；</p></li><li><p>具体产品（Concrete Product）：实现了抽象产品角色所定义的接口，有具体工厂来创建，它同具体工厂之间一一对应。</p></li></ol><p><img src="http://cdn.zhouxug.cn/20201026215042.png" alt="image-20201026215042251"></p><h5 id="3-1-2-模式的实现"><a href="#3-1-2-模式的实现" class="headerlink" title="3.1.2 模式的实现"></a>3.1.2 模式的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂：提供了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂：实现了厂品的生成方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">newProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体工厂1生成--&gt;具体产品1...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品：提供了产品的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品：实现抽象产品中的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体产品1显示...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-模式应用场景"><a href="#3-2-模式应用场景" class="headerlink" title="3.2 模式应用场景"></a>3.2 模式应用场景</h4><p>工厂方法模式通常适用于以下场景。</p><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li><li>创建对象的任务由多个具体工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li><li>客户不关心创建产品的细节，只关心产品的品牌。</li></ul><h4 id="3-3-模式的拓展"><a href="#3-3-模式的拓展" class="headerlink" title="3.3 模式的拓展"></a>3.3 模式的拓展</h4><img src="http://cdn.zhouxug.cn/20201026220150.png" alt="image-20201026220150193" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML</title>
      <link href="2020/10/24/UML/"/>
      <url>2020/10/24/UML/</url>
      
        <content type="html"><![CDATA[<h1 id="UML概念"><a href="#UML概念" class="headerlink" title="UML概念"></a>UML概念</h1><blockquote><p>UML是Unified Model Language的缩写，中文是统一建模语言，是由一整套图表组成的标准化建模语言。</p></blockquote><p>UML分类：</p><ul><li>结构图分为类图、轮廓图、组件图、组合结构图、对象图、部署图、包图。</li><li>行为图又分活动图、用例图、状态机图和交互图。</li><li>交互图又分为序列图、时序图、通讯图、交互概览图。</li></ul><img src="http://cdn.zhouxug.cn/20201024201343.png" alt="image-20201024201343588" style="zoom: 67%;" /><h1 id="UML各类图"><a href="#UML各类图" class="headerlink" title="UML各类图"></a>UML各类图</h1><h3 id="1-类图"><a href="#1-类图" class="headerlink" title="1. 类图"></a>1. 类图</h3><blockquote><ul><li>【概念】 类图是一切面向对象方法的核心建模工具。类图描述了系统中对象的类型以及它们之间存在的各种静态关系。</li><li>【目的】用来表示类、接口以及它们之间的静态结构和关系。</li></ul></blockquote><ol><li>泛化</li></ol><ul><li>【泛化关系】是一种<strong>继承关系</strong>，表示子类继承父类的所有特征和行为。</li><li>【箭头指向】带三角箭头的实线，箭头指向父类。</li></ul><p><img src="http://cdn.zhouxug.cn/20201024201716.png" alt="image-20201024201716514"></p><ol start="2"><li>实现</li></ol><ul><li>【实现关系】是一种<strong>类与接口的关系</strong>，表示类是接口所有特征和行为的实现。</li><li>【箭头指向】带三角箭头的虚线，箭头指向接口</li></ul><p><img src="http://cdn.zhouxug.cn/20201024201755.png" alt="image-20201024201755548"></p><ol start="3"><li>关联</li></ol><ul><li>【关联关系】是一种<strong>拥有关系，它使得一个类知道另一个类的属性和方法</strong>。</li><li>【代码体现】成员变量</li><li>【箭头指向】带普通箭头的实线，<strong>由拥有者出发，指向被拥有者。双向的关联可以有两个箭头，或者没有箭头。</strong>单向的关联有一个箭头。</li></ul><p><strong>关联的几种实例：</strong></p><ol><li>0..1：可以有0或1个实例</li><li>0..*：对实例数没有规定</li><li>1：只能有1个实例</li><li>1..*：至少1个实例</li></ol><p><strong>tip：两个类间可以由不同角色标识存在的多个关联</strong></p><p><img src="http://cdn.zhouxug.cn/20201025192709.png" alt="image-20201025192709681"></p><hr><p><img src="http://cdn.zhouxug.cn/20201024201819.png" alt="image-20201024201819861"></p><p><u>    自己买的车，想什么时候开就开。但是车是车，人是人，没有整体与部分的关系。</u></p><ol start="4"><li>聚合</li></ol><ul><li>【聚合关系】是一种整体与部分的关系。且部分可以离开整体而单独存在。聚合关系是<strong>关联关系的一种</strong>，<strong>是强的关联关系；</strong>关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</li><li>【代码体现】成员变量</li><li>【箭头指向】带空心菱形的实线，空心菱形指向整体。</li></ul><p><img src="http://cdn.zhouxug.cn/20201024202046.png" alt="image-20201024202046020"></p><p><u>    电脑有键盘才能输入信息，电脑是整体，键盘是部分，键盘也可以离开电脑，单纯的拿去敲。所以是聚合。</u></p><ol start="5"><li>组合</li></ol><ul><li>【组合关系】是一种整体与部分的关系。但部分不能离开整体而单独存在，<strong>组合关系是关联关系的一种，是比聚合关系还要强的关系。</strong></li><li>【代码体现】成员变量</li><li>【箭头指向】带实心菱形的实线，实心菱形指向整体。</li></ul><p><img src="http://cdn.zhouxug.cn/20201024202652.png" alt="image-20201024202652563"></p><p><u>    鸟是整体，翅膀是部分。鸟死了，翅膀也就不能飞了。所以是组合。</u></p><p><img src="http://cdn.zhouxug.cn/20201024202816.png" alt="image-20201024202816386"></p><p><u>    一个公司拥有多个部门，公司和部门之间是组合关系，公司破产了，部门就不复存在了。部门和员工是<strong>聚合关系，部门被裁掉，员工就换下家了</strong>。</u></p><ol start="6"><li>依赖</li></ol><ul><li>【依赖关系】是一种使用关系，即一个类的实现需要另一个类的协助。</li><li>【箭头指向】带普通箭头的虚线，<strong>由使用者出发，指向被使用者。</strong></li></ul><p><img src="http://cdn.zhouxug.cn/20201024202947.png" alt="image-20201024202947444"></p><p><u>    老司机只管开车，车是谁的不重要，给什么车开什么车。</u></p><h3 id="2-对象图"><a href="#2-对象图" class="headerlink" title="2. 对象图"></a>2. 对象图</h3><blockquote><ul><li>【概念】<strong>对象图是类图的一个实例</strong>，是系统在某个时间点的详细状态的快照。</li><li>【目的】用来表示两个或者多个对象之间在某一时刻之间的关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024205006.png" alt="image-20201024205006239"></p><p><u>    某时间点bat这个公司有一个研发部，一个销售部，两个部门只有一个人iisheng</u></p><h3 id="3-用例图"><a href="#3-用例图" class="headerlink" title="3. 用例图"></a>3. 用例图</h3><blockquote><ul><li>【概念】用例图是指由参与者、用例，边界以及它们之间的关系构成的用于描述系统功能的视图。</li><li>【目的】用来描述整个系统的功能。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024205223.png" alt="image-20201024205223259"></p><p>用例图中包含以下三种关系：</p><ul><li>包含关系使用符号《include》，想要查看订单列表，前提是需要先登录。</li><li>扩展关系使用符号《extend》，基于查询订单列表的功能，可以增加一个导出数据的功能</li><li>泛化关系，子用例继承父用例所有结构、行为和关系。</li></ul><h3 id="4-序列图"><a href="#4-序列图" class="headerlink" title="4. 序列图"></a>4. 序列图</h3><blockquote><ul><li>【概念】序列图根据时间序列展示对象如何进行协作。它展示了在用例的特定场景中，对象如何与其他对象交互。</li><li>【目的】通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024205553.png" alt="image-20201024205552968"></p><p><u>    图中展示的是支付宝条码支付场景的序列图。其中，loop是循环，alt是选择。</u></p><h3 id="5-通讯图"><a href="#5-通讯图" class="headerlink" title="5. 通讯图"></a>5. 通讯图</h3><blockquote><ul><li>【概念】描述了收发消息的对象的组织关系，强调<strong>对象之间的合作关系</strong>而不是时间顺序。</li><li>【目的】用来显示不同对象的关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024205803.png" alt="image-20201024205803312"></p><p><u>    图中展示了一个线上书店的通讯图，方框和小人表示生命线，不同生命线之间可以传递消息，消息前面的数字可以表达序列顺序。</u></p><h3 id="6-交互概览图"><a href="#6-交互概览图" class="headerlink" title="6. 交互概览图"></a>6. 交互概览图</h3><blockquote><ul><li>【概念】交互概览图与活动图类似，但是<strong>它的节点都是交互图。</strong></li><li>【目的】提供了控制流的概述。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024211257.png" alt="image-20201024211256976"></p><p><u>    图中表示一个调度系统的交互概览图，跟活动图很像。其中sd的框代表具体的交互流程，ref框代表使用交互。</u></p><h3 id="7-时序图"><a href="#7-时序图" class="headerlink" title="7. 时序图"></a>7. 时序图</h3><blockquote><ul><li>【概念】时序图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。</li><li>【目的】用来表示元素状态或者值随时间的变化而变化的视图。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024211514.png" alt="image-20201024211514237"></p><p><u>图中展示了老年痴呆病人随着时间的变化病情的变化。</u></p><h3 id="8-状态图"><a href="#8-状态图" class="headerlink" title="8. 状态图"></a>8. 状态图</h3><blockquote><ul><li>【概念】状态图对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。</li><li>【目的】用来表示指定对象，在整个生命周期，响应不同事件的不同状态。</li></ul></blockquote><p><strong>状态图中转换的五要素</strong></p><ol><li>原状态</li><li>目标状态</li><li>触发事件</li><li>监护条件：布尔表达式，决定是否激活</li><li>动作：转换激活时的动作</li></ol><p><img src="http://cdn.zhouxug.cn/20201024211610.png" alt="image-20201024211610023"></p><p><u>图中描述了，门在其生命周期内所经历的状态。</u></p><h3 id="9-活动图"><a href="#9-活动图" class="headerlink" title="9. 活动图"></a>9. 活动图</h3><blockquote><ul><li>【概念】描述了具体业务用例的实现流程。</li><li>【目的】用来表示用例实现的工作流程。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024211902.png" alt="image-20201024211902500"></p><p><u>图中简单描述了，从开始到登录到查看订单列表，或者登录失败直接结束。</u></p><h3 id="10-结构图-组件图"><a href="#10-结构图-组件图" class="headerlink" title="10. 结构图 / 组件图"></a>10. 结构图 / 组件图</h3><blockquote><ul><li>【概念】描绘了系统中组件提供的、需要的接口、端口等，以及它们之间的关系。</li><li>【目的】用来展示各个组件之间的依赖关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212110.png" alt="image-20201024212110463"></p><p><u>订单系统组件依赖于客户资源库和库存系统组件。中间的虚线箭头表示依赖关系。另外两个符号，表示组件连接器，一个提供接口，一个需要接口。</u></p><h3 id="11-组合结构图"><a href="#11-组合结构图" class="headerlink" title="11. 组合结构图"></a>11. 组合结构图</h3><blockquote><ul><li>【概念】描述了一个”组合结构”的内部结构，以及他们之间的关系。这个”组合结构”可以是系统的一部分，或者一个整体。</li><li>【目的】用来表示系统中逻辑上的”组合结构”。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212223.png" alt="image-20201024212223750"></p><p><u>图中描述了Car是由车轴连接着的两个前面轮子、两个后面轮子，和引擎组合的。</u></p><h3 id="12-部署图"><a href="#12-部署图" class="headerlink" title="12. 部署图"></a>12. 部署图</h3><blockquote><ul><li>【概念】描述了系统内部的软件如何分布在不同的节点上。</li><li>【目的】用来表示软件和硬件的映射关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212347.png" alt="image-20201024212347530"></p><p><u>图中简单的表示，不同机器上面部署的不同软件。</u></p><h3 id="13-包图"><a href="#13-包图" class="headerlink" title="13. 包图"></a>13. 包图</h3><blockquote><ul><li>【概念】描绘了系统在包层面上的结构设计。</li><li>【目的】用来表示包和包之间的依赖关系。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212502.png" alt="image-20201024212502812"></p><ul><li>《Use》关系表示使用依赖，Web Shopping依赖Payment</li><li>《Merge》关系表示合并，Web Shopping合并了Shopping Cart就拥有了Shopping Cart的功能</li><li>《Access》关系表示私有引入，比如代码中的指定包名类名</li><li>《Import》关系表示公共引入，比如Java中的import之后，就可以直接使用import包中的类了</li></ul><h3 id="14-轮廓图"><a href="#14-轮廓图" class="headerlink" title="14. 轮廓图"></a>14. 轮廓图</h3><blockquote><ul><li>【概念】轮廓图提供了一种通用的扩展机制，用于为特定域和平台定制UML模型。</li><li>【目的】用于在特定领域中构建UML模型。</li></ul></blockquote><p><img src="http://cdn.zhouxug.cn/20201024212903.png" alt="image-20201024212902942"></p><p><u>图中我们定义了一个简易的EJB的概要图。Bean是从Component扩展来的。Entity Bean和Session Bean继承了Bean。EJB拥有Remote和Home接口，和JAR包。</u></p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 面向对象技术</title>
      <link href="2020/10/24/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/"/>
      <url>2020/10/24/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="7-1-面向对象基础"><a href="#7-1-面向对象基础" class="headerlink" title="7.1 面向对象基础"></a>7.1 面向对象基础</h1><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><blockquote><p>面向对象 = 对象 + 分类 + 继承 + 通过消息的通信</p></blockquote><ol><li>对象：最基本的运行时实体，包含数据和行为</li><li>消息：对象之间的通信的一种<strong>构造</strong>叫消息</li><li>类：大体相似的对象</li><li>继承</li><li>多态</li></ol><h3 id="2-对象、消息传递和方法"><a href="#2-对象、消息传递和方法" class="headerlink" title="2. 对象、消息传递和方法"></a>2. 对象、消息传递和方法</h3><blockquote><p>对象是类的实体，尽管对象的表示在形式上与一般数据类型相似，但是它们之间的本质区别，<strong>对象之间通过消息传递方式进行通信</strong></p></blockquote><h1 id="7-2-UML"><a href="#7-2-UML" class="headerlink" title="7.2 UML"></a><a href="https://sinan106.github.io/2020/10/24/UML/">7.2 UML</a></h1><h1 id="7-3-设计模式"><a href="#7-3-设计模式" class="headerlink" title="7.3 设计模式"></a><a href="https://sinan106.github.io/2020/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">7.3 设计模式</a></h1><h1 id="7-4-题目补充"><a href="#7-4-题目补充" class="headerlink" title="7.4 题目补充"></a>7.4 题目补充</h1><ol><li>采用面向对象开发，在分析阶段，架构师主要关注系统的<strong>行为</strong>，即系统应该做什么</li></ol>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT的四种使用方式</title>
      <link href="2020/10/19/JWT%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
      <url>2020/10/19/JWT%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><ol><li>access_token 过期设置为15分钟</li><li>前端发起请求，后端验证access_token是否过期；如果过期，前端发起refresh_token请求，后端设置已再次授权标记为true，请求成功</li><li>前端发起请求，后端验证再次授权标记，如果已经再次授权，则拒绝refresh_token的请求，请求成功</li><li>如果前端每隔72小时，必须重新登录，后端检查用户最后一次登录日期，如超过72小时，则拒绝刷新token的请求，请求失败</li></ol><h1 id="1-0实现"><a href="#1-0实现" class="headerlink" title="1.0实现"></a>1.0实现</h1><ol><li><p>登录成功，返回access_token和refresh_token，客户端缓存此两种token;</p></li><li><p>使用access_token请求接口资源，成功则调用成功；如果token超时，客户端携带refresh_token调用中间件接口获取新的access_token;</p></li><li><p>中间件接受refresh_token的请求后，检查refresh_token是否过期。<br>如过期，拒绝刷新，客户端收到该状态后，跳转到登录页；<br>如未过期，生成新的access_token和refresh_token并返回给客户端（如有可能，让旧的refresh_token失效），客户端携带新的access_token重新调用上面的资源接口。</p></li><li><p>客户端退出登录或修改密码后，调用中间件注销旧的token(使access_token和refresh_token失效)，同时清空客户端的access_token和refresh_toke。</p><p> 后端表<br> id user_id client_id client_secret refresh_token expire_in create_date del_flag</p></li></ol><h1 id="2-0实现"><a href="#2-0实现" class="headerlink" title="2.0实现"></a>2.0实现</h1><p>场景： access_token访问资源 refresh_token授权访问 设置固定时间X必须重新登录</p><ol><li>登录成功，后台jwt生成access_token（jwt有效期30分钟）和refresh_token（jwt有效期15天），并缓存到redis（hash-key为token,sub-key为手机号,value为设备唯一编号（根据手机号码，可以人工废除全部token，也可以根据sub-key,废除部分设备的token。），设置过期时间为1个月(redis)，保证最终所有token都能删除)，返回后，客户端缓存此两种token;</li><li>使用access_token请求接口资源，校验成功且redis中存在该access_token（未废除）则调用成功；如果token超时，中间件删除access_token（废除）；客户端再次携带refresh_token调用中间件接口获取新的access_token;</li><li>中间件接受刷新token的请求后，检查refresh_token是否过期。<br> 如过期，拒绝刷新，删除refresh_token（废除）； 客户端收到该状态后，跳转到登录页；<br> 如未过期，检查缓存中是否有refresh_token（是否被废除），如果有，则生成新的access_token并返回给客户端，客户端接着携带新的access_token重新调用上面的资源接口。</li><li>客户端退出登录或修改密码后，调用中间件注销旧的token(中间件删除access_token、refresh_token（废除）)，同时清空客户端侧的access_token和refresh_toke。</li><li>如手机丢失，可以根据手机号人工废除指定用户设备关联的token。</li><li>以上3刷新access_token可以增加根据登录时间判断最长X时间必须重新登录，此时则拒绝刷新token。（拒绝的场景：失效，长时间未登录，频繁刷新）</li></ol><h3 id="2-0-变动"><a href="#2-0-变动" class="headerlink" title="2.0 变动"></a>2.0 变动</h3><p>1.登录<br>2.登录拦截器<br>3.增加刷新access_token接口<br>4.退出登录<br>5.修改密码</p><h1 id="3-0实现"><a href="#3-0实现" class="headerlink" title="3.0实现"></a>3.0实现</h1><p>场景：自动续期 长时间未使用需重新登录</p><ol><li>登录成功，后台jwt生成access_token（jwt有效期30分钟），并缓存到redis（hash-key为access_token,sub-key为手机号,value为设备唯一编号（根据手机号码，可以人工废除全部token），设置access_token过期时间为7天，保证最终所有token都能删除)，返回后，客户端缓存此token;</li><li>使用access_token请求接口资源，校验成功且redis中存在该access_token（未废除）则调用成功；如果token超时，中间件删除access_token（废除）,同时生成新的access_token并返回。客户端收到新的access_token，<br>再次请求接口资源。</li><li>客户端退出登录或修改密码后，调用中间件注销旧的token(中间件删除access_token（废除）)，同时清空客户端侧的access_token。</li><li>以上2 可以增加根据登录时间判断最长X时间必须重新登录，此时则拒绝刷新token。（拒绝的场景：长时间未登录，频繁刷新）</li><li>如手机丢失，可以根据手机号人工废除指定用户设备关联的token。</li></ol><h3 id="3-0-变动"><a href="#3-0-变动" class="headerlink" title="3.0 变动"></a>3.0 变动</h3><p>1.登录<br>2.登录拦截器<br>3.退出登录<br>4.修改密码</p><h1 id="4-0实现"><a href="#4-0实现" class="headerlink" title="4.0实现"></a>4.0实现</h1><p>场景：token过期重新登录 长时间未使用需重新登录</p><p>1.登录成功，后台jwt生成access_token（jwt有效期7天），并缓存到redis，key为”user_id:access_token” + 用户id,value为access_token（根据用户id，可以人工废除指定用户全部<br>token），设置缓存过期时间为7天，保证最终所有token都能删除，请求返回后，客户端缓存此access_token；<br>2.使用access_token请求接口资源，校验成功且redis中存在该access_token（未废除）则调用成功；如果token超时，中间件删除access_token（废除）,同时生成新的access_token并返回。客户端收到新的access_token，再次请求接口资源。<br>3.客户端退出登录或修改密码后，调用中间件注销旧的token(中间件删除access_token（废除）)，同时清空客户端侧的access_token。<br>4.以上2 可以增加根据登录时间判断最长X时间必须重新登录，此时则拒绝刷新token。（拒绝的场景：长时间未登录，频繁刷新）<br>5.如手机丢失，可以根据手机号人工废除指定用户设备关联的token。</p><h3 id="4-0-变动"><a href="#4-0-变动" class="headerlink" title="4.0 变动"></a>4.0 变动</h3><p>1.登录<br>2.登录拦截器<br>3.退出登录<br>4.修改密码</p><h1 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h1><h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><ol><li>在登录接口中 如果校验账号密码成功 则根据用户id和用户类型创建jwt token(有效期设置为-1，即永不过期),得到A</li><li>更新登录日期(当前时间new Date()即可)（业务上可选），得到B</li><li>在redis中缓存key为ACCESS_TOKEN:userId:A(加上A是为了防止用户多个客户端登录 造成token覆盖),value为B的毫秒数（转换成字符串类型），过期时间为7天（7 * 24 * 60 * 60）</li><li>在登录结果中返回json格式为{“result”:”success”,”token”: A}</li><li>用户在接口请求header中携带token进行登录，后端在所有接口前置拦截器进行拦截，作用是解析token 拿到userId和用户类型（用户调用业务接口只需要传token即可）， 如果解析失败（抛出SignatureException），则返回json（code = 0 ,info= Token验证不通过, errorCode = ‘1001’）； 此外如果解析成功，验证redis中key为ACCESS_TOKEN:userId:A 是否存在 如果不存在 则返回json（code = 0 ,info= 会话过期请重新登录, errorCode = ‘1002’）； 如果缓存key存在，则自动续7天超时时间（value不变），实现频繁登录用户免登陆。</li><li>把userId和用户类型放入request参数中 接口方法中可以直接拿到登录用户信息</li><li>如果是修改密码或退出登录 则废除access_tokens（删除key）</li></ol><h1 id="前端（VUE）"><a href="#前端（VUE）" class="headerlink" title="前端（VUE）"></a>前端（VUE）</h1><ol><li>用户登录成功，则把username存入cookie中，key为loginUser;把token存入cookie中，key为accessToken 把token存入Vuex全局状态中</li><li>进入首页</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea创建 maven tomcat项目</title>
      <link href="2020/10/19/idea%E5%88%9B%E5%BB%BA-maven-tomcat%E9%A1%B9%E7%9B%AE/"/>
      <url>2020/10/19/idea%E5%88%9B%E5%BB%BA-maven-tomcat%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-新建maven项目-选择webapp"><a href="#1-新建maven项目-选择webapp" class="headerlink" title="1. 新建maven项目 选择webapp"></a>1. 新建maven项目 选择webapp</h1><p><img src="https://img-blog.csdnimg.cn/20200715162502382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjExODkz,size_16,color_FFFFFF,t_70" alt="新建"></p><h1 id="2-导包后Edit-Configurations-选择tomcat-和-jdk-如有报错-fix-即可-war包部署选择-war-exploded，URL是选择每次运行时默认打开的链接，可以和后续的Application-Context配置一样"><a href="#2-导包后Edit-Configurations-选择tomcat-和-jdk-如有报错-fix-即可-war包部署选择-war-exploded，URL是选择每次运行时默认打开的链接，可以和后续的Application-Context配置一样" class="headerlink" title="2. 导包后Edit Configurations,选择tomcat 和 jdk 如有报错 fix 即可,war包部署选择 war:exploded，URL是选择每次运行时默认打开的链接，可以和后续的Application Context配置一样"></a>2. 导包后Edit Configurations,选择tomcat 和 jdk 如有报错 fix 即可,war包部署选择 war:exploded，URL是选择每次运行时默认打开的链接，可以和后续的Application Context配置一样</h1><p><img src="https://img-blog.csdnimg.cn/202007151626513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjExODkz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="3-接着打开Deployment，里面就已经有个war包了，-然后修改-Application-Context-这就是你url的访问路径"><a href="#3-接着打开Deployment，里面就已经有个war包了，-然后修改-Application-Context-这就是你url的访问路径" class="headerlink" title="3. 接着打开Deployment，里面就已经有个war包了，==然后修改 Application Context== 这就是你url的访问路径"></a>3. 接着打开Deployment，里面就已经有个war包了，==然后修改 Application Context== 这就是你url的访问路径</h1><p><img src="https://img-blog.csdnimg.cn/20200715163050658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjExODkz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="4-运行即可，会显示index-jsp的内容"><a href="#4-运行即可，会显示index-jsp的内容" class="headerlink" title="4.运行即可，会显示index.jsp的内容"></a>4.运行即可，会显示index.jsp的内容</h1>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="2020/10/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2020/10/19/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Lambda 一个重要用法是简化某些<em>匿名内部类</em>，或者说是对<em>函数式接口</em>的实现。</p><blockquote><p>函数式接口(Functional Interface)是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。(@Functional interface修饰)</p></blockquote><p>简单例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; &#123;<span class="keyword">return</span> <span class="number">5</span>&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">(x) -&gt; &#123;<span class="keyword">return</span> <span class="number">2</span> * x&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;<span class="keyword">return</span> x – y&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; &#123;System.out.print(s)&#125;</span><br></pre></td></tr></table></figure><p>省略写法：</p><ol><li>省略参数类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; &#123;<span class="keyword">return</span> x – y&#125; </span><br></pre></td></tr></table></figure></li><li>单个参数省略小括号(无参时要写小括号)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; &#123;<span class="keyword">return</span> <span class="number">2</span> * x&#125;  </span><br></pre></td></tr></table></figure></li><li>无返回且仅有一条语句，省略大括号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure></li><li>有返回且仅有一条语句，省略return 和 大括号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br></pre></td></tr></table></figure><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1></li><li>静态方法调用（通过类调用）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReMultiple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; <span class="comment">//唯一的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">syntax3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接用类名加方法名调用</span></span><br><span class="line">ReMultiple lam3 = syntax3::fun1;</span><br><span class="line">System.out.println(lam3.show(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// out: 7</span></span><br></pre></td></tr></table></figure></li><li>Java8 常用内置函数式接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.Predicate 参数T 返回值boolean 用于判定</span></span><br><span class="line"><span class="comment">// 若为偶数则返回真</span></span><br><span class="line">Predicate&lt;Integer&gt; predicate = t -&gt; t%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line"><span class="comment">// removeIf(Predicate)(将list中的每个对象都通过Predicate，若为真则删除)</span></span><br><span class="line">list.removeIf(predicate);</span><br><span class="line">list.forEach(System.out::print); <span class="comment">// out: 135 因为246为偶数 返回真 被删除了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Consumer 参数T 无返回 用于消费某值</span></span><br><span class="line">Consumer&lt;Integer&gt; consumer = System.out::print;</span><br><span class="line">   list.forEach(consumer); <span class="comment">//123456</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">//3. Function 参数T 输出R 用于类型转换</span></span><br><span class="line">String str = <span class="string">&quot;aaaaaa&quot;</span>;</span><br><span class="line">   Function&lt;String, Integer&gt; function = String::length;</span><br><span class="line">   System.out.println(function.apply(str)); <span class="comment">//out: 6</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 结构化开发</title>
      <link href="2020/10/19/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>2020/10/19/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1-结构化开发"><a href="#6-1-结构化开发" class="headerlink" title="6. 1 结构化开发"></a>6. 1 结构化开发</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><blockquote><ol><li>指导思想是自顶向下、逐层分解</li><li>基本原则是功能的分解与抽象</li><li>适合于数据处理领域的问题，但是不适合解决大规模、特别复杂的项目，难以适应需求的变化</li></ol></blockquote><h3 id="2-系统设计的基本原理"><a href="#2-系统设计的基本原理" class="headerlink" title="2.系统设计的基本原理"></a>2.系统设计的基本原理</h3><h5 id="1-抽象"><a href="#1-抽象" class="headerlink" title="1. 抽象"></a>1. 抽象</h5><h5 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2. 模块化"></a>2. 模块化</h5><h5 id="3-信息屏蔽"><a href="#3-信息屏蔽" class="headerlink" title="3. 信息屏蔽"></a>3. 信息屏蔽</h5><h5 id="4-模块独立-衡量模块独立程度的标准：耦合性和内聚性"><a href="#4-模块独立-衡量模块独立程度的标准：耦合性和内聚性" class="headerlink" title="4. 模块独立 : 衡量模块独立程度的标准：耦合性和内聚性"></a>4. 模块独立 : 衡量模块独立程度的标准：耦合性和内聚性</h5><ol><li><p>耦合</p><blockquote><p>模块间相对独立性的度量</p></blockquote><ol><li>无直接耦合：没有任何关系</li><li>数据耦合：两模块间传递简单的数据值 / 值传递</li><li>标记耦合：传递数据结构</li><li>控制耦合：一个模块调用另一个时传递变量，被调模块通过变量值不同来决定执行那个功能。被调模块通常有多个功能</li><li>外部耦合：通过软件之外的环境联结，<strong>如通过IO设备耦合到特定设备、格式、通信协议</strong></li><li>公共耦合：通过一个公共数据环境相互作用，<strong>如全局的变量或数据结构</strong></li><li>内容耦合：一个模块直接使用另一个模块的内部数据，或通过非正常入口进入另一个模块</li></ol></li><li><p>内聚</p><blockquote><p>一个模块内部各个元素结合的繁密程度</p></blockquote><ol><li>偶然/巧合内聚：一个模块内各元素都没有任何联系</li><li>逻辑内聚：模块内执行若干逻辑上相似的功能，通过参数确定该模块完成哪一个功能</li><li>时间内聚：同时执行的动作组合在一起，<strong>如系统初始化</strong></li><li>过程内聚：一个模块完成多个任务，这些任务必须按照指定的顺序进行</li><li>通信内聚：模块内的所有处理元素都在一个数据结构上操作，或者处理使用相同的输入数据或者产生相同的输出数据，<strong>如向某个数据结构读/写数据</strong></li><li>顺序内聚：模块中的任务必须顺序执行，且前一个的输出就是下一个的输入</li><li>功能内聚：模块内的所有元素共同完成一个功能，缺一不可</li></ol><p> <strong>Tip：顺序内聚强调数据间的传递，然而过程内聚不强调</strong></p></li></ol><h3 id="3-扇入系数与扇出系数"><a href="#3-扇入系数与扇出系数" class="headerlink" title="3. 扇入系数与扇出系数"></a>3. 扇入系数与扇出系数</h3><blockquote><p>一个模块直接调用其他模块的个数称为模块的扇出系数，反之，被调用的次数被称为扇入系数。</p><p>一般扇入和扇出系数为3，4，不会超过7</p></blockquote><h1 id="6-2-数据流图"><a href="#6-2-数据流图" class="headerlink" title="6.2 数据流图"></a>6.2 数据流图</h1><blockquote><p>数据流图也称为数据流程图(Data Flow Diagram DFD)</p></blockquote><h4 id="基本元素："><a href="#基本元素：" class="headerlink" title="基本元素："></a>基本元素：</h4><ul><li>数据流<img src="http://cdn.zhouxug.cn/20201019194428.png" alt="image-20201019194428595" style="zoom:50%;" /></li></ul><ul><li>加工<img src="http://cdn.zhouxug.cn/20201019194349.png" alt="image-20201019194349384" style="zoom:50%;" /></li></ul><ul><li>数据存储<img src="http://cdn.zhouxug.cn/20201019194404.png" alt="image-20201019194404865" style="zoom:50%;" /></li></ul><ul><li>外部实体<img src="http://cdn.zhouxug.cn/20201019194327.png" alt="image-20201019194327089" style="zoom:50%;" /></li></ul><h1 id="6-3-集成测试策略"><a href="#6-3-集成测试策略" class="headerlink" title="6.3 集成测试策略"></a>6.3 集成测试策略</h1><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ol><li>驱动模块：根据测试用例的设计去调用被测试模块</li><li>桩模块：用于模拟某下级模块“代替/假”模块，并可以模拟各种返回值</li></ol><p>简单的说，被测模块上层为驱动模块，是调用被测模块的，被测模块下层为桩模块，是被被测模块调用的。</p><h3 id="2-各类测试分类"><a href="#2-各类测试分类" class="headerlink" title="2. 各类测试分类"></a>2. 各类测试分类</h3><h4 id="1-自顶向下"><a href="#1-自顶向下" class="headerlink" title="1. 自顶向下"></a>1. 自顶向下</h4><blockquote><p> ​    采用了和设计一样的顺序对系统进行测试，它在第一时间内对系统的控制接口进行验证；采用自顶向下的集成测试首先集中于顶层的组件，然后逐步测试处于底层的组件；可采用深度优先和广度优先策略。</p></blockquote><ul><li><p>优点：</p><ul><li>在测试过程中较早的验证了主要的控制和判断点</li><li>在过程的早期阶段测试，有助于最大限度地减少对驱动程序的需求</li></ul></li><li><p>缺点：</p><ul><li>桩的开发和维护时本策略的最大成本</li><li>底层组件行为的验证被推迟了</li><li>不能很好地支持有限功能的早期发布</li></ul></li></ul><h4 id="2-自顶向上"><a href="#2-自顶向上" class="headerlink" title="2. 自顶向上"></a>2. 自顶向上</h4><blockquote><p>​    由下而上的方法要求首先测试和集成最低级别的单元。这些单元常被称为实用工具模块。</p></blockquote><ul><li>优点：<ul><li>实用工具模块在开发过程的早期阶段测试，最大限度地减少了对桩的需求</li><li>最初的工作可以并行</li><li>支持故障隔离</li></ul></li><li>缺点：<ul><li>驱动的开发工作量大</li><li>高层的验证被推迟</li><li>设计上的错误不容易发现</li></ul></li></ul><h4 id="3-三明治"><a href="#3-三明治" class="headerlink" title="3. 三明治"></a>3. 三明治</h4><blockquote><p>​    把系统划分成三层，中间一层为目标层；测试的时候，对目标层上面的一层使用由顶向下的集成策略，对目标层下面的一层使用自底向上的集成策略，最后测试在目标层会合。</p></blockquote><ul><li>优点：<ul><li>可以较早的验证主要的控制和判断点和底层模块（集合了自顶向下和自底向上的优点）</li></ul></li><li>缺点：<ul><li>中间层的在被集成前测试不充分</li></ul></li></ul><h4 id="4-一次性-大爆炸"><a href="#4-一次性-大爆炸" class="headerlink" title="4. 一次性/大爆炸"></a>4. 一次性/大爆炸</h4><blockquote><p>首先对每个模块分别进行单元测试，然后再把所有单元组装在一起进行测试，最终得到要求的软件系统</p></blockquote><ul><li><p>缺点：</p><ul><li>由于程序中不可避免地存在模块间接口、全局数据结构等方面的问题，所以一次试运行成功的可能性并不很大</li><li>在发现错误的时候，其问题定位和修改都比较困难；</li><li>即使被测系统能够被一次性集成，但还是会有许多接口错误很容易的躲过测试而进入到系统测试范围内。</li></ul></li><li><p>适用范围</p><ul><li>维护型或增强型项目，之前的项目已经足够稳定</li><li>系统较小</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 结构化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-plus_hello</title>
      <link href="2020/10/18/Mybatis-plus_hello/"/>
      <url>2020/10/18/Mybatis-plus_hello/</url>
      
        <content type="html"><![CDATA[<h1 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h1><h4 id="config-MyBatisPlus-Config"><a href="#config-MyBatisPlus-Config" class="headerlink" title="config.MyBatisPlus-Config"></a>config.MyBatisPlus-Config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 标记为配置文件</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.zhouxug.hello.dao&quot;)</span>  <span class="comment">// 扫描DAO层文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  分页插件 分页具体使用会在后续讲述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dao-BlogMapper-被扫描文件"><a href="#dao-BlogMapper-被扫描文件" class="headerlink" title="dao.BlogMapper 被扫描文件"></a>dao.BlogMapper 被扫描文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span> <span class="comment">// 作为仓库 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Blog</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//继承自 BaseMapper&lt;T&gt; 泛型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-自动填充"><a href="#2-自动填充" class="headerlink" title="2. 自动填充"></a>2. 自动填充</h1><h4 id="config-MyMetaObjectHandler"><a href="#config-MyMetaObjectHandler" class="headerlink" title="config.MyMetaObjectHandler"></a>config.MyMetaObjectHandler</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需实现 MetaObjectHandler 中 insertFill 和 updateFill 方法</span></span><br><span class="line"><span class="comment"> * 使用时就要取消掉数据库的自动填充</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入时填充</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// setFieldValByName </span></span><br><span class="line">        <span class="comment">// 第一个参数是你要填充字段的  实体名称  ！！！</span></span><br><span class="line">        <span class="comment">// 第二个为填充值</span></span><br><span class="line">        <span class="comment">// 第三个为元数据</span></span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;blogPostTime&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;blogUpdateTime&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新时填充</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setFieldValByName(<span class="string">&quot;blogUpdateTime&quot;</span>, <span class="keyword">new</span> Date(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-分页插件"><a href="#3-分页插件" class="headerlink" title="3. 分页插件"></a>3. 分页插件</h1><h4 id="config-MyBatisPlus-Config-1"><a href="#config-MyBatisPlus-Config-1" class="headerlink" title="config.MyBatisPlus-Config"></a>config.MyBatisPlus-Config</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在config中配置分页插件 </span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 使用Page来指定分页</span></span><br><span class="line"><span class="comment">// current 为当前第几页 从一开始</span></span><br><span class="line"><span class="comment">// size 为每一页的行数</span></span><br><span class="line">Page&lt;Attachment&gt; page = <span class="keyword">new</span> Page&lt;&gt;(current, size);</span><br><span class="line">   QueryWrapper&lt;Attachment&gt; wrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">   wrapper.orderByDesc(<span class="string">&quot;upload_time&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用mapper 中的selectPage 来传入wrapper 和 page 参数 从而达到分页</span></span><br><span class="line">   IPage&lt;Attachment&gt; attachmentIPage = attachmentMapper.selectPage(page, wrapper);</span><br><span class="line">   List&lt;Attachment&gt; records = attachmentIPage.getRecords();</span><br></pre></td></tr></table></figure><h1 id="4-自定义SQL"><a href="#4-自定义SQL" class="headerlink" title="4. 自定义SQL"></a>4. 自定义SQL</h1><h4 id="1-注解方式"><a href="#1-注解方式" class="headerlink" title="1. 注解方式"></a>1. 注解方式</h4><h4 id="dao-UserMapper-声明并定义方法"><a href="#dao-UserMapper-声明并定义方法" class="headerlink" title="dao.UserMapper 声明并定义方法"></a>dao.UserMapper 声明并定义方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Mapper文件中直接定义方法</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set user_name = #&#123;user_name&#125;, description = #&#123;description&#125;, icon = #&#123;icon&#125; where email = #&#123;email&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUserInfo</span><span class="params">(<span class="meta">@Param(&quot;user_name&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;description&quot;)</span> String description,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;icon&quot;)</span> String icon,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;email&quot;)</span> String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最后通过service-Impl-通过mapper调用"><a href="#最后通过service-Impl-通过mapper调用" class="headerlink" title="最后通过service.Impl 通过mapper调用"></a>最后通过service.Impl 通过mapper调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.updateUserInfo();</span><br></pre></td></tr></table></figure><h4 id="2-XML方式"><a href="#2-XML方式" class="headerlink" title="2. XML方式"></a>2. XML方式</h4><h4 id="application-yml-指定mapper-xml位置"><a href="#application-yml-指定mapper-xml位置" class="headerlink" title="application.yml 指定mapper.xml位置"></a>application.yml 指定mapper.xml位置</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="comment"># 如果是放在src/main/java目录下 classpath:/com/\*/*/mapper/\*Mapper.xml*</span></span><br><span class="line"><span class="comment"># 如果是放在resource目录 classpath:/mapper/**.xml*</span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/**.xml</span></span><br></pre></td></tr></table></figure><h4 id="dao-UserMapper-声明方法"><a href="#dao-UserMapper-声明方法" class="headerlink" title="dao.UserMapper 声明方法"></a>dao.UserMapper 声明方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Mapper文件中直接定义方法</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">selectByName</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="UserMapper-xml-定义SQL"><a href="#UserMapper-xml-定义SQL" class="headerlink" title="UserMapper.xml 定义SQL"></a>UserMapper.xml 定义SQL</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zhouxug.hello.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.model.User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user where name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="最后通过service-Impl-通过mapper调用-1"><a href="#最后通过service-Impl-通过mapper调用-1" class="headerlink" title="最后通过service.Impl 通过mapper调用"></a>最后通过service.Impl 通过mapper调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.updateUserInfo();</span><br></pre></td></tr></table></figure><h1 id="5-时间查询"><a href="#5-时间查询" class="headerlink" title="5. 时间查询"></a>5. 时间查询</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply 拼接sql 语句</span></span><br><span class="line"><span class="comment">// 使用date_format(数据库字段名， &#x27;%Y&#x27;/&#x27;%m&#x27;/&#x27;%d&#x27;)</span></span><br><span class="line">wrapper.apply(<span class="string">&quot;date_format(post_time, &#x27;%Y&#x27;) = &#123;0&#125;&quot;</span>, <span class="string">&quot;2020&quot;</span>);</span><br><span class="line">List&lt;Blog&gt; blogList = blogMapper.selectList(wrapper);</span><br></pre></td></tr></table></figure><h1 id="6-遇到的一些坑"><a href="#6-遇到的一些坑" class="headerlink" title="6. 遇到的一些坑"></a>6. 遇到的一些坑</h1><h4 id="1-Update-User表中的userName时，sql拼接会缺失userName"><a href="#1-Update-User表中的userName时，sql拼接会缺失userName" class="headerlink" title="1. Update User表中的userName时，sql拼接会缺失userName"></a>1. Update User表中的userName时，sql拼接会缺失userName</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要代码</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUserName(<span class="string">&quot;new&quot;</span>);</span><br><span class="line">wrapper.eq(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;@example.com&quot;</span>);</span><br><span class="line">userMapper.update(user, wrapper);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql :  update user ser where email = &#123; &#125; </span></span><br><span class="line"><span class="comment">// 应当为 ： update user ser user_name = “new” where email = &#123; &#125;</span></span><br></pre></td></tr></table></figure><h5 id="解决方式：使用自定义sql-updateUserInfo"><a href="#解决方式：使用自定义sql-updateUserInfo" class="headerlink" title="解决方式：使用自定义sql : updateUserInfo"></a>解决方式：使用自定义sql : updateUserInfo</h5><h4 id="dao-UserMapper"><a href="#dao-UserMapper" class="headerlink" title="dao.UserMapper"></a>dao.UserMapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update user set user_name = #&#123;user_name&#125;, description = #&#123;description&#125;, icon = #&#123;icon&#125; where email = #&#123;email&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateUserInfo</span><span class="params">(<span class="meta">@Param(&quot;user_name&quot;)</span> String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;description&quot;)</span> String description,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;icon&quot;)</span> String icon,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="meta">@Param(&quot;email&quot;)</span> String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最后通过service-Impl-通过mapper调用-2"><a href="#最后通过service-Impl-通过mapper调用-2" class="headerlink" title="最后通过service.Impl 通过mapper调用"></a>最后通过service.Impl 通过mapper调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userMapper.updateUserInfo();</span><br></pre></td></tr></table></figure><h4 id="2-wrapper-select-获取部分字段时实体类与数据库映射失败"><a href="#2-wrapper-select-获取部分字段时实体类与数据库映射失败" class="headerlink" title="2. wrapper.select 获取部分字段时实体类与数据库映射失败"></a>2. wrapper.select 获取部分字段时实体类与数据库映射失败</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果实体类与数据库字段是驼峰式对应，则没有问题</span></span><br><span class="line"><span class="comment">// 但是如果是别名，哪怕设置了 @TableField(value = &quot;&quot;) 仍会无法映射</span></span><br><span class="line"> wrapper.select(<span class="string">&quot;post_time&quot;</span>);</span><br><span class="line"><span class="comment">// sql : SELECT post_time FROM blog</span></span><br><span class="line"><span class="comment">// 应当为 : SELECT post_time AS blogPostTime FROM blog</span></span><br><span class="line"><span class="comment">// 这里post_time别名为 blogPostTime 并且设置了@TableField(value = &quot;blogPostTime&quot;) 但是仍有问题</span></span><br></pre></td></tr></table></figure><h5 id="解决方法1：使用select-Class-entityClass-Predicate-predicate"><a href="#解决方法1：使用select-Class-entityClass-Predicate-predicate" class="headerlink" title="解决方法1：使用select(Class entityClass, Predicate predicate)"></a>解决方法1：使用select(Class<T> entityClass, Predicate<TableFieldInfo> predicate)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为查询的实体类</span></span><br><span class="line"><span class="comment">// 第二个参数为lambda表达式 </span></span><br><span class="line"><span class="comment">// getColumn().equals() 是数据库中的字段名</span></span><br><span class="line"><span class="comment">// getProperty().equals() 是实体类中的字段名</span></span><br><span class="line"><span class="comment">// 连接多个字段使用 &amp;&amp; 连接</span></span><br><span class="line"><span class="comment">// !表示排除这个字段 反之为需要这个字段</span></span><br><span class="line">wrapper.select(Blog.class, i -&gt; !i.getColumn().equals(<span class="string">&quot;update_time&quot;</span>)</span><br><span class="line">        &amp;&amp; !i.getProperty().equals(<span class="string">&quot;blogContent&quot;</span>));</span><br><span class="line"></span><br><span class="line">wrapper.select(Blog.class, i -&gt; i.getColumn().equals(<span class="string">&quot;post_time&quot;</span>))；</span><br></pre></td></tr></table></figure><h5 id="解决方法2：使用select-String-column-手动拼接字段"><a href="#解决方法2：使用select-String-column-手动拼接字段" class="headerlink" title="解决方法2：使用select(String column)手动拼接字段"></a>解决方法2：使用select(String column)手动拼接字段</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrapper.select(<span class="string">&quot;post_time AS blogPostTime&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sql : SELECT post_time AS blogPostTime FROM blog </span></span><br><span class="line"><span class="comment">// 感觉 select(column)是直接拼接进去的</span></span><br></pre></td></tr></table></figure><h5 id="题外话：distinct的使用"><a href="#题外话：distinct的使用" class="headerlink" title="题外话：distinct的使用"></a>题外话：distinct的使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接加在 数据库字段名前即可 </span></span><br><span class="line"><span class="comment">// 但是目前不知道 select(Class, Predicate) 如何使用</span></span><br><span class="line">select(<span class="string">&quot;distinct post_time AS blogPostTime&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-主键自增问题"><a href="#3-主键自增问题" class="headerlink" title="3. 主键自增问题"></a>3. 主键自增问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的type = IdType.AUTO自增是指依靠数据库自增，而不是mp来填充</span></span><br><span class="line">    <span class="comment">// 所以数据库id一定要填自增</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer tagId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String tagName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 软件工程基础</title>
      <link href="2020/10/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>2020/10/18/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="5-1-软件工程概述"><a href="#5-1-软件工程概述" class="headerlink" title="5.1 软件工程概述"></a>5.1 软件工程概述</h1><h3 id="能力成熟度模型-CMM"><a href="#能力成熟度模型-CMM" class="headerlink" title="能力成熟度模型 CMM"></a>能力成熟度模型 CMM</h3><blockquote><p>对软件过后曾组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进，软件组织的能力经过这些阶段逐步提高。</p></blockquote><p>CMM将软件过程改进分为以下5个成熟度级别</p><ol><li><p>初始级</p></li><li><p>可重复级</p></li><li><p>已定义级</p></li><li><p>已管理级</p></li><li><p>优化级</p></li></ol><h1 id="5-2-软件过程模型"><a href="#5-2-软件过程模型" class="headerlink" title="5.2 软件过程模型"></a>5.2 软件过程模型</h1><h3 id="1-瀑布模型"><a href="#1-瀑布模型" class="headerlink" title="1. 瀑布模型"></a>1. 瀑布模型</h3><blockquote><p>​    将软件生存周期中的各个活动规定为依线性顺序连接的若干阶段的模型，它规定了由前至后、相互衔接的固定次序，如同瀑布流水逐级下落</p></blockquote><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ol><li>容易理解，管理成本低</li><li>强调开发的阶段性早期计划及需求调查和产品测试</li></ol><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>要求客户必须完整、正确和清晰的表达他们的需要</li><li>在开始的两三个阶段中很难评估真正的进度状态，在快结束时会有大量的集成测试工作，直到整个项目完成之前都不能演示系统的能力</li><li>需求或设计中的错误往往只有到了后期才能发现，<strong>对于项目风险的控制能力较弱</strong>。</li></ol><h3 id="2-增量模型​"><a href="#2-增量模型​" class="headerlink" title="2. 增量模型​"></a>2. 增量模型​</h3><blockquote><p>​    假设将需求分段为一系列增量产品，每一增量可以分别开发。该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”</p></blockquote><img src="http://cdn.zhouxug.cn/20201018104619.png" alt="增量模型" style="zoom:125%;" /><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ol><li>瀑布模型所有优点</li><li>第一个可交付版本所需的成本和时间很少</li><li>开发由增量表示的小系统所承担的风险较小</li></ol><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>若没有对用户的变更要求进行规划，那么产生的初始增量有可能导致之后的增量不稳定</li><li>若需求不像早期思考的那样稳定和完整，一些增量就可能要重新开发，重新发布</li><li>管理成本、进度和配置的复杂性较高</li></ol><h3 id="3-原型模型"><a href="#3-原型模型" class="headerlink" title="3. 原型模型"></a>3. 原型模型</h3><blockquote><p>​    原型是预期系统的一个可执行版本，反应了系统性质的一个子集。一个原型不必满足所有约束，其目的是快速、低成本的构建原型。然后交付给客户使用，并收集反馈意见，这些意见将在下一轮中对原型进行改进。</p></blockquote><h5 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h5><p>​    适合在开发初期用户需求不清晰或经常变化的情况。当系统不太复杂时，采用该方法比较好</p><h4 id="增量模型与原型模型的区别"><a href="#增量模型与原型模型的区别" class="headerlink" title="增量模型与原型模型的区别"></a>增量模型与原型模型的区别</h4><ol><li>增量的迭代可以并行，而原型不行</li><li>增量是一般具有底层框架和平台的项目，而原型则是开发需求不明确、架构风险打的项目。</li></ol><h3 id="4-螺旋模型"><a href="#4-螺旋模型" class="headerlink" title="4. 螺旋模型"></a>4. 螺旋模型</h3><blockquote><p>​    对于复杂的大型软件，开发一个原型通常达不到要求。螺旋模型将瀑布模型和演化结合起来，加入了风险分析。</p></blockquote><p>螺旋模型将开发过程分为几个螺旋周期，每个周期大致和瀑布模型相符。四步流程如下</p><ol><li>制定计划</li><li>风险分析</li><li>实施工程</li><li>用户评估</li></ol><p><img src="http://cdn.zhouxug.cn/20201018104623.png" alt="螺旋模型"></p><p><strong>螺旋模型强调风险分析，<u>因此特别适合庞大、复杂且具有高风险的系统</u></strong>    ctrl + u 下划线</p><h5 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h5><ol><li>支持用户需求的动态变化，有助于提高软件的适应能力</li><li>为项目管理人员及时调整管理决策提供了便利，从而降低了风险</li></ol><h5 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>要求开发人员有相当丰富的风险评估能力和专业知识</li><li>过多的迭代次数会增加开发成本，延迟提交时间</li></ol><h3 id="5-喷泉模型"><a href="#5-喷泉模型" class="headerlink" title="5. 喷泉模型"></a>5. 喷泉模型</h3><blockquote><p>以用户需求为动力，以对象作为驱动的模型，<strong>适合面向对象的开发</strong></p></blockquote><p><img src="http://cdn.zhouxug.cn/20201018104628.png" alt="image-20201014193317591"></p><h5 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h5><ol><li>克服了瀑布模型和多项开发活动集成的局限性</li><li>允许各个开发活动交叉迭代进行，不必每次 需求分析 -&gt; 设计活动 -&gt; 编码，提高开发效率节省了大量开发时间</li></ol><h5 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>由于开发的各个阶段是重叠的，需要大量的开发人员，不利于项目管理</li><li>要求严格的文档管理，审核难度大</li></ol><h3 id="6-统一过程模型-UP"><a href="#6-统一过程模型-UP" class="headerlink" title="6. 统一过程模型 UP"></a>6. 统一过程模型 UP</h3><blockquote><p>“用例和风险驱动，以架构为中心，迭代并且增量”的开发模型</p></blockquote><p>统一过程定义了4个技术阶段及其制品</p><ol><li>起始阶段：生命周期目标</li><li>精化阶段：生命周期架构</li><li>构建阶段：初始运作功能</li><li>移交阶段：产品发布</li></ol><h3 id="7-敏捷方法"><a href="#7-敏捷方法" class="headerlink" title="7. 敏捷方法"></a>7. 敏捷方法</h3><blockquote><p>软件开发过程中加入灵活性，能在开发周期的后期增加或改变需求</p></blockquote><h4 id="1-极限编程-XP"><a href="#1-极限编程-XP" class="headerlink" title="1. 极限编程 XP"></a>1. 极限编程 XP</h4><blockquote><p>主要解决代码质量低的问题，无法提升代码速度</p></blockquote><p>四大价值观：</p><ol><li>沟通</li><li>简单性</li><li>反馈</li><li>勇气</li></ol><h4 id="2-水晶法-Crystal"><a href="#2-水晶法-Crystal" class="headerlink" title="2. 水晶法 Crystal"></a>2. 水晶法 Crystal</h4><blockquote><p>每一个不同的项目都需要一套不同的策略、约定和方法论，认为人对软件质量有重要的影响。通过更好地交流和经常性的交付，软件生产力得到提高</p></blockquote><h4 id="3-并列争求法-Scrum"><a href="#3-并列争求法-Scrum" class="headerlink" title="3. 并列争求法 Scrum"></a>3. 并列争求法 Scrum</h4><blockquote><p>使用迭代的方法，把每30天一次的迭代称为一个“冲刺”。多个自组织和自治的小组<strong>并行</strong>地递增且<strong>竞争</strong>实现产品。</p></blockquote><h4 id="4-自适应软件开发-ASD"><a href="#4-自适应软件开发-ASD" class="headerlink" title="4. 自适应软件开发 ASD"></a>4. 自适应软件开发 ASD</h4><h1 id="5-3-测试方法"><a href="#5-3-测试方法" class="headerlink" title="5.3 测试方法"></a>5.3 测试方法</h1><h3 id="1-黑盒测试"><a href="#1-黑盒测试" class="headerlink" title="1. 黑盒测试"></a>1. 黑盒测试</h3><blockquote><p>也称为功能测试，在完全不考虑软件内部结构和特性情况下，测试软件外部特性</p></blockquote><h3 id="2-白盒测试"><a href="#2-白盒测试" class="headerlink" title="2.白盒测试"></a>2.白盒测试</h3><blockquote><p>也成为结构测试，根据程序内部机构和逻辑来设计测试用例，对程序的路径和过程进行测试</p></blockquote><h5 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1. 语句覆盖"></a>1. 语句覆盖</h5><p>只用满足一个案例，走过所有的语句即可</p><h5 id="2-判定-分支-覆盖"><a href="#2-判定-分支-覆盖" class="headerlink" title="2. 判定(分支)覆盖"></a>2. 判定(分支)覆盖</h5><p>对于判断语句，要设定T/F，相比语句覆盖，新增False</p><img src="http://cdn.zhouxug.cn/20201018104631.png" alt="image-20201017153157639" style="zoom:80%;" /><h5 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3. 条件覆盖"></a>3. 条件覆盖</h5><p>判断语句中变量每个值都要考虑一遍</p><img src="http://cdn.zhouxug.cn/20201018104634.png" alt="image-20201017153212357" style="zoom:80%;" /><h5 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定/条件覆盖"></a>4. 判定/条件覆盖</h5><p>判定覆盖各条件覆盖交叉，针对于判定中的条件取值 </p><img src="http://cdn.zhouxug.cn/20201018104636.png" alt="image-20201017153319004" style="zoom:80%;" /><h5 id="5-组合覆盖"><a href="#5-组合覆盖" class="headerlink" title="5. 组合覆盖"></a>5. 组合覆盖</h5><img src="http://cdn.zhouxug.cn/20201018104638.png" alt="image-20201017153349607" style="zoom:80%;" /><h5 id="6-路径覆盖"><a href="#6-路径覆盖" class="headerlink" title="6. 路径覆盖"></a>6. 路径覆盖</h5><img src="http://cdn.zhouxug.cn/20201018104642.png" alt="image-20201017153412730" style="zoom:80%;" /><h1 id="5-4-进度管理"><a href="#5-4-进度管理" class="headerlink" title="5.4 进度管理"></a>5.4 进度管理</h1><h3 id="1-Gantt图"><a href="#1-Gantt图" class="headerlink" title="1. Gantt图"></a>1. Gantt图</h3><blockquote><p>清晰地描述每个任务从何时开始，到何时结束，任务进度进展情况以及各个任务之间的并行性。但是不能反映各任务间的依赖关系，难以确定项目的关键</p></blockquote><p><img src="http://cdn.zhouxug.cn/20201018104644.png" alt="image-20201017153850807"></p><h3 id="2-PERT图-（类似AOE网）"><a href="#2-PERT图-（类似AOE网）" class="headerlink" title="2. PERT图 （类似AOE网）"></a>2. PERT图 （类似AOE网）</h3><blockquote><p>PERT图给出了每个任务的开始时间、结束时间该任务完成所需时间，还给出了任务间的关系，即哪些任务完成后才能开始另一项任务。<strong>松弛时间反映了完成某些任务时可以推迟其开始时间或延长完成时间</strong>，但是PERT图不能反映任务间的并行关系。</p></blockquote><h1 id="5-5-软件评审"><a href="#5-5-软件评审" class="headerlink" title="5.5 软件评审"></a>5.5 软件评审</h1><h3 id="1-软件质量的评审内容"><a href="#1-软件质量的评审内容" class="headerlink" title="1. 软件质量的评审内容"></a>1. 软件质量的评审内容</h3><ol><li>功能结构：在软件设计中占有极其重要的地位，软件评审时必须明确软件的数据结构，需检查的项目如下<ol><li>数据结构</li><li>功能结构</li><li>数据结构和功能结构之间的对应关系</li></ol></li><li>功能的通用性</li><li>模块的层次</li><li>模块结构</li></ol><h1 id="5-6-软件度量"><a href="#5-6-软件度量" class="headerlink" title="5.6 软件度量"></a>5.6 软件度量</h1><h3 id="1-McCabe-度量法"><a href="#1-McCabe-度量法" class="headerlink" title="1. McCabe 度量法"></a>1. McCabe 度量法</h3><blockquote><p>又称为环路度量，他认为循环和选择构成的环路越多，程序就越复杂。他把程序流程图中的每个处理符号都退化成为一个结点，原来连接不同处理符号的流线变成连接不同点的有向弧，这样得到的有向图称为<strong>程序图</strong>。</p></blockquote><p>*<em>McCabe环路复杂度: V(G) = m - n = 2 * p*</em></p><p><strong>m 是图G中弧的个数，n是图G的结点数，p是G中的强连通分量个数，通常取1</strong></p><p>ps: </p><ol><li>顶点强连通：有向图中u,v两点，u -&gt; v, v -&gt; u 都有一条有向的路径，则称这两点连通</li><li>强连通图：若所有节点都是强连通，则该图为强连通图</li><li>强连通分量：有向非连通图的极大强连通子图</li></ol><p>当环路复杂度超过10时，要充分测试这个模块就变得十分困难，</p>]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/17/hello-world/"/>
      <url>2020/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
